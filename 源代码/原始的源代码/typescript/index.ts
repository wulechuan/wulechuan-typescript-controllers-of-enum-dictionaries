import {
    是合规的非列表对象,
    求合规的非列表对象_按需构造空的对象,
    求合规的非列表对象_若不合规则给出null,
} from './辅助工具集_通用'

import {
    是字典之合规的唯一标识,
    // 是字典数据项之合规的唯一标识,
} from './辅助工具集_字典机专用'

export * from './辅助工具集_字典机专用'





export type 范_字典之唯一标识 = string; // | number;
export type 范_字典项之唯一标识 = string | number;

export interface 范_界面标准项_最简形态<范_项值 = any, 范_负载 = any> {
    唯一标识: 范_字典项之唯一标识;
    在界面中的称谓: string;
    值: 范_项值;

    // 应禁用?: boolean;

    /**  为求实用，每个界面项可挂负载。例如，可将该【界面标准项】对应的【数据原项】作为负载。 */
    负载?: 范_负载;
}



export type 范_界面标准项_之列表<
    范_界面标准项 extends 范_界面标准项_最简形态 = 范_界面标准项_最简形态<any, any>
> = Array<范_界面标准项>;

export type 范_界面标准项_之哈希表<
    范_界面标准项 extends 范_界面标准项_最简形态 = 范_界面标准项_最简形态<any, any>
> = { [数据项之唯一标识: string]: 范_界面标准项; };



export type 范_数据映射表_从值至界面措辞 = { [值对应之文本: string]: string; };
export type 范_数据映射表_从界面措辞至值<范_项值 = any> = { [某项在界面中的称谓: string]: 范_项值; };



export type 范_某字典_代表全选的字典项<
    范_该字典_界面标准项 extends 范_界面标准项_最简形态 = 范_界面标准项_最简形态<any, any>
> = {
    应位于候选列表之该处: '首部' | '尾部';
    界面标准项: 范_该字典_界面标准项;
};

export type 范_某字典_代表全都不选的字典项<
    范_该字典_界面标准项 extends 范_界面标准项_最简形态 = 范_界面标准项_最简形态<any, any>
> = {
    应位于候选列表之该处: '首部' | '尾部';
    界面标准项: 范_该字典_界面标准项;
};



export type 范_单个字典之数据映射表之构建方案 = (
    /**
     * 我假想有些字典表虽然项值数量有限，但项值之取值可能性则为无限。故而设计该种方案。
     *
     * 例如，
     * 某字典表为某种【款项】之列表。这样的字典表，
     * 其各项之【界面措辞】须借助所谓【格式化程序】求得。例如，讲数字按英美的三位一组分隔，或将数字转换为汉字形式等。
     * 于此种情形，我认为没必要为该种字典构建【数据映射表】，因实用价值不高。
     */
    | '不必构建'

    /**
     * 较多的服务端程序员提供的字典【数据原项】同时包含【值】于【自然语言称谓】。
     * 典型的如：{ id, name } 或 { value, label } 等。
     *
     * 于此种情形，【数据映射表】应借助该【数据原项】表构建而得。且于【界面标准项】表而言，这些【数据映射表】无用途，即为备用。
     */
    | '从数据原项集中提取而得'

    /**
     * 有些简单的字典，客户端会“写死”一个或一对哈希表，用以映射【值 ~ 界面措辞】，
     * 而不是通过 XHR 从服务端获取。故而设计该种方案。
     *
     * 于此种情形，服务端给出的【数据原项】应该不提供【自然语言称谓】字段，否则该字典的【数据映射表】的构建方案没必要配置为该种方案。
     * 且【数据映射表】应当参与【界面标准项】表的构建过程。即，【界面标准项】须用到这些【数据映射表】。
     */
    | '脱离数据原项集单独构建，一次性即可'

    /**
     * 此为假想的情形。暂无例证。
     */
    | '脱离数据原项集单独构建，且须反复获取或构建'
);

export const 单个字典之诸数据映射表之所有可能的构建方案: Array<范_单个字典之数据映射表之构建方案> = [
    '不必构建',
    '从数据原项集中提取而得',
    '脱离数据原项集单独构建，一次性即可',
    '脱离数据原项集单独构建，且须反复获取或构建',
]

export const 单个字典之诸数据映射表之默认构建方案: 范_单个字典之数据映射表之构建方案 = '从数据原项集中提取而得'



export type 范_用以构建单个字典机之配置项总集_完备形式<
    范_该字典_数据原项 = any,
    范_该字典_界面标准项 extends 范_界面标准项_最简形态 = 范_界面标准项_最简形态<any, any>
> = {
    该字典之唯一标识: string;

    配置项集: {
        代表全选的字典项?: null | Partial<范_某字典_代表全选的字典项<范_该字典_界面标准项>>;
        代表全都不选的字典项?: null | Partial<范_某字典_代表全都不选的字典项<范_该字典_界面标准项>>;

        该字典诸数据映射表之构建方案?: 范_单个字典之数据映射表之构建方案;

        在该字典所属的字典群初始化时不应获取或构建该字典的数据?: boolean;
        不应构建界面标准项之列表?: boolean;
        应构建界面标准项之哈希表?: boolean;
    };

    事件处理程序集: {
        构建或获取原始数据集?: (
            ...参数表: any[]
        ) => Promise<Array<范_该字典_数据原项>>;

        脱离数据原项集构建诸数据映射表?: () => Promise<{
            从界面措辞至值: 范_数据映射表_从界面措辞至值<范_该字典_界面标准项['值']>;
            从值至界面措辞: 范_数据映射表_从值至界面措辞;
        }>;

        凭数据原项集构建诸数据映射表?: (
            该字典_数据原项集: Array<范_该字典_数据原项>
        ) => Promise<{
            从界面措辞至值: 范_数据映射表_从界面措辞至值<范_该字典_界面标准项['值']>;
            从值至界面措辞: 范_数据映射表_从值至界面措辞;
        }>;

        凭某数据原项构建界面标准项?: (
            该字典_某数据原项: 范_该字典_数据原项
        ) => 范_该字典_界面标准项;
    };
};

export type 范_用以构建单个字典机之配置项总集_准用形式<
    范_该字典_数据原项 = any,
    范_该字典_界面标准项 extends 范_界面标准项_最简形态 = 范_界面标准项_最简形态<any, any>
> = {
    该字典之唯一标识: string;

    配置项集?: {
        代表全选的字典项?: null | Partial<范_某字典_代表全选的字典项<范_该字典_界面标准项>>;
        代表全都不选的字典项?: null | Partial<范_某字典_代表全都不选的字典项<范_该字典_界面标准项>>;

        该字典诸数据映射表之构建方案?: 范_单个字典之数据映射表之构建方案;

        在该字典所属的字典群初始化时不应获取或构建该字典的数据?: boolean;
        不应构建界面标准项之列表?: boolean;
        应构建界面标准项之哈希表?: boolean;
    };

    事件处理程序集?: {
        构建或获取原始数据集?: (
            ...参数表: any[]
        ) => Promise<Array<范_该字典_数据原项>>;

        脱离数据原项集构建诸数据映射表?: () => Promise<{
            从界面措辞至值: 范_数据映射表_从界面措辞至值<范_该字典_界面标准项['值']>;
            从值至界面措辞: 范_数据映射表_从值至界面措辞;
        }>;

        凭数据原项集构建诸数据映射表?: (
            该字典_数据原项集: Array<范_该字典_数据原项>
        ) => Promise<{
            从界面措辞至值: 范_数据映射表_从界面措辞至值<范_该字典_界面标准项['值']>;
            从值至界面措辞: 范_数据映射表_从值至界面措辞;
        }>;

        凭某数据原项构建界面标准项?: (
            该字典_某数据原项: 范_该字典_数据原项
        ) => 范_该字典_界面标准项;
    };
};



export type 范_字典机<
    范_该字典_数据原项 = any,
    范_该字典_界面标准项 extends 范_界面标准项_最简形态 = 范_界面标准项_最简形态<any, any>
> = {
    该字典之唯一标识: string;

    状态集: {
        该字典诸数据映射表之构建方案: 范_单个字典之数据映射表之构建方案;
        该字典诸数据映射表业已构建完毕: boolean;

        /**
         * 有些字典，依赖于其它变量，须临时反复构建。且往往在模块加载初始时不必构建。
         *
         * 例如，【中标企业】须在【已参选的投标企业】中选择。
         * 故【中标企业】对应的候选列表字典应根据【已参选企业】这一变量的值来临时构建。
         */
        在该字典所属的字典群初始化时不应获取或构建该字典的数据: boolean;

        /**
         * 该所谓“逆向”哈希表用途不广，不及列表形式。故默认不构建该哈希表，以节省计算。
         * 但为了简化【守卫】代码，即便不构建该哈希表，本工具仍令该哈希表之取值为 {} ，而非 null 。
         */
        应构建界面标准项之哈希表: boolean;

        当下的数据系某次成功构建而得的: boolean;
    };

    数据集: {
        代表全选的字典项: null | 范_某字典_代表全选的字典项<范_该字典_界面标准项>;
        代表全都不选的字典项: null | 范_某字典_代表全都不选的字典项<范_该字典_界面标准项>;

        数据原项集: null | Array<范_该字典_数据原项>;

        界面标准项集: {
            列表形式: 范_界面标准项_之列表<范_该字典_界面标准项>;
            哈希表形式: 范_界面标准项_之哈希表<范_该字典_界面标准项>;
        };

        数据映射表集: {
            从界面措辞至值: 范_数据映射表_从界面措辞至值<范_该字典_界面标准项['值']>;
            从值至界面措辞: 范_数据映射表_从值至界面措辞;
        };
    };

    行为: {
        清空数据: () => void;
        重建数据: (...用以获取数据原项集的参数表: any[]) => Promise<void>;
        求某项值之称谓: (项值?: any) => string | null | undefined;
    };

    _幕后行为: {
        凭数据原项集构建界面标准项集: () => void;
        按需构建诸数据映射表: () => Promise<void>;
    };

    _事件处理程序集: {
        构建或获取原始数据集: (
            ...参数表: any[]
        ) => Promise<Array<范_该字典_数据原项>>;

        脱离数据原项集构建诸数据映射表?: () => Promise<{
            从界面措辞至值: 范_数据映射表_从界面措辞至值<范_该字典_界面标准项['值']>;
            从值至界面措辞: 范_数据映射表_从值至界面措辞;
        }>;

        凭数据原项集构建诸数据映射表?: (
            该字典_数据原项集: Array<范_该字典_数据原项>
        ) => Promise<{
            从界面措辞至值: 范_数据映射表_从界面措辞至值<范_该字典_界面标准项['值']>;
            从值至界面措辞: 范_数据映射表_从值至界面措辞;
        }>;

        凭某数据原项构建界面标准项: (
            该字典_某数据原项: 范_该字典_数据原项
        ) => 范_该字典_界面标准项;
    };
};



export type 范_字典机之集之列表形式<
    范_该组字典_数据原项_可能的默认形态 = any,
    范_该组字典_界面标准项_各形态之交集 extends 范_界面标准项_最简形态 = 范_界面标准项_最简形态<any, any>
> = Array<
    范_字典机<范_该组字典_数据原项_可能的默认形态, 范_该组字典_界面标准项_各形态之交集>
>;



export type 范_字典机之集之哈希表形式<
    范_该组字典_数据原项_可能的默认形态 = any,
    范_该组字典_界面标准项_各形态之交集 extends 范_界面标准项_最简形态 = 范_界面标准项_最简形态<any, any>
> = {
    [字典之唯一标识: string]: 范_字典机<范_该组字典_数据原项_可能的默认形态, 范_该组字典_界面标准项_各形态之交集>;
};



export type 范_任何字典_凭数据原项集构建诸数据映射表_默认做法<
    范_某次调用期间所操作之字典_数据原项_默认形态 = any,
    范_某次调用期间所操作之字典_项值_默认形态 = any
> = (
    该字典_数据原项集: Array<范_某次调用期间所操作之字典_数据原项_默认形态>
) => Promise<{
    从界面措辞至值: 范_数据映射表_从界面措辞至值<范_某次调用期间所操作之字典_项值_默认形态>;
    从值至界面措辞: 范_数据映射表_从值至界面措辞;
}>;



export type 范_任何字典_凭某数据原项构建界面标准项_默认做法<
    范_某次调用期间所操作之字典_数据原项_默认形态 = any,
    范_某次调用期间所操作之字典_界面标准项_默认形态 extends 范_界面标准项_最简形态 = 范_界面标准项_最简形态<any, any>
> = (该字典_某数据原项: 范_某次调用期间所操作之字典_数据原项_默认形态) => 范_某次调用期间所操作之字典_界面标准项_默认形态;



export type 范_用以构建字典群之总机之配置项总集_完备形式<
    范_该总机内所有字典_数据原项_可能的默认形态 = any,
    范_该总机内所有字典_界面标准项_各形态之交集 extends 范_界面标准项_最简形态 = 范_界面标准项_最简形态<any, any>
> = {
    不应自动初始化: boolean;

    最初的一批用以构建字典机的配置项集之列表: Array<
        范_用以构建单个字典机之配置项总集_准用形式<any, 范_该总机内所有字典_界面标准项_各形态之交集>
    >;

    事件处理程序集: {
        任何字典_凭数据原项集构建诸数据映射表_默认做法?: 范_任何字典_凭数据原项集构建诸数据映射表_默认做法<
            范_该总机内所有字典_数据原项_可能的默认形态,
            范_该总机内所有字典_界面标准项_各形态之交集['值']
        >;

        任何字典_凭某数据原项构建界面标准项_默认做法?: 范_任何字典_凭某数据原项构建界面标准项_默认做法<
            范_该总机内所有字典_数据原项_可能的默认形态,
            范_该总机内所有字典_界面标准项_各形态之交集
        >;
    };
};

export type 范_用以构建字典群之总机之配置项总集_准用形式<
    范_该总机内所有字典_数据原项_可能的默认形态 = any,
    范_该总机内所有字典_界面标准项_各形态之交集 extends 范_界面标准项_最简形态 = 范_界面标准项_最简形态<any, any>
> = {
    不应自动初始化?: boolean;

    最初的一批用以构建字典机的配置项集之列表?: Array<
        范_用以构建单个字典机之配置项总集_准用形式<any, 范_该总机内所有字典_界面标准项_各形态之交集>
    >;

    事件处理程序集?: {
        任何字典_凭数据原项集构建诸数据映射表_默认做法?: 范_任何字典_凭数据原项集构建诸数据映射表_默认做法<
            范_该总机内所有字典_数据原项_可能的默认形态,
            范_该总机内所有字典_界面标准项_各形态之交集['值']
        >;

        任何字典_凭某数据原项构建界面标准项_默认做法?: 范_任何字典_凭某数据原项构建界面标准项_默认做法<
            范_该总机内所有字典_数据原项_可能的默认形态,
            范_该总机内所有字典_界面标准项_各形态之交集
        >;
    };
};



export type 范_字典群之总机成批重建字典的执行方案 = (
    /** 例如由 `追加一批字典` 新追加的那些字典机。 */
    | '仅限从未构建过数据的的字典参与'

    /** 即为 `在该字典所属的字典群初始化时不应获取或构建该字典的数据` 之特征取 'true' 的那些字典机，哪怕它们曾经成功初始化过。 */
    | '所有具备自动初始化特征的字典均参与'

    /** 即为一切字典机。换句话说，忽略各字典机各自的 `在该字典所属的字典群初始化时不应获取或构建该字典的数据` 之特征。 */
    | '强制一切字典参与'
);

export const 成批重建字典数据时之所有可能的方案: Array<范_字典群之总机成批重建字典的执行方案> = [
    '仅限从未构建过数据的的字典参与',
    '所有具备自动初始化特征的字典均参与',
    '强制一切字典参与',
]



export type 范_字典群之总机<
    范_该总机内所有字典_数据原项_可能的默认形态 = any,
    范_该总机内所有字典_界面标准项_各形态之交集 extends 范_界面标准项_最简形态 = 范_界面标准项_最简形态<any, any>
> = {
    字典机之集: {
        列表形式: 范_字典机之集之列表形式<
            any,
            范_该总机内所有字典_界面标准项_各形态之交集
        >;

        哈希表形式: 范_字典机之集之哈希表形式<
            any,
            范_该总机内所有字典_界面标准项_各形态之交集
        >;
    };

    状态集: {
        期待_初始化任务已完成: Promise<void>;
        初始化任务仍在运转: boolean;
        初始化任务已经成功: boolean;
    },

    行为: {
        初始化: (强制重新初始化?: boolean) => Promise<void>;

        追加一批字典: <范_该组字典_数据原项_可能的默认形态 = 范_该总机内所有字典_数据原项_可能的默认形态>(
            用以构建一批字典机之配置项集之列表?: Array<
                范_用以构建单个字典机之配置项总集_准用形式<范_该组字典_数据原项_可能的默认形态, 范_该总机内所有字典_界面标准项_各形态之交集>
            >
        ) => void;

        取某字典机: <
            范_该字典_数据原项 = 范_该总机内所有字典_数据原项_可能的默认形态,
            范_该字典_界面标准项 extends 范_该总机内所有字典_界面标准项_各形态之交集 = 范_该总机内所有字典_界面标准项_各形态之交集
        >(
            欲索取之字典之唯一标识?: 范_字典之唯一标识
        ) => (null | 范_字典机<范_该字典_数据原项, 范_该字典_界面标准项>);

        取某字典之界面标准项之列表: <
            范_该字典_数据原项 = 范_该总机内所有字典_数据原项_可能的默认形态,
            范_该字典_界面标准项 extends 范_该总机内所有字典_界面标准项_各形态之交集 = 范_该总机内所有字典_界面标准项_各形态之交集
        >(
            欲索取其中数据之字典之唯一标识?: 范_字典之唯一标识
        ) => 范_界面标准项_之列表<范_该字典_界面标准项>;

        取某字典之界面标准项之哈希表: <
            范_该字典_数据原项 = 范_该总机内所有字典_数据原项_可能的默认形态,
            范_该字典_界面标准项 extends 范_该总机内所有字典_界面标准项_各形态之交集 = 范_该总机内所有字典_界面标准项_各形态之交集
        >(
            欲索取其中数据之字典之唯一标识?: 范_字典之唯一标识
        ) => 范_界面标准项_之哈希表<范_该字典_界面标准项>;

        令所有字典按需重建数据: (
            本次执行须为哪些字典重建数据?: 范_字典群之总机成批重建字典的执行方案
        ) => Promise<void>;
    };

    _幕后行为: {
        按需追加单个字典: <
            范_该字典_数据原项 = 范_该总机内所有字典_数据原项_可能的默认形态,
            范_该字典_界面标准项 extends 范_该总机内所有字典_界面标准项_各形态之交集 = 范_该总机内所有字典_界面标准项_各形态之交集
        >(
            用以构建该字典机之配置项总集?: 范_用以构建单个字典机之配置项总集_准用形式<范_该字典_数据原项, 范_该字典_界面标准项>
        ) => (null | 范_字典机<范_该字典_数据原项, 范_该字典_界面标准项>);
    };

    _事件处理程序集: {
        任何字典_凭数据原项集构建诸数据映射表_默认做法?: 范_任何字典_凭数据原项集构建诸数据映射表_默认做法<
            范_该总机内所有字典_数据原项_可能的默认形态,
            范_该总机内所有字典_界面标准项_各形态之交集['值']
        >;

        任何字典_凭某数据原项构建界面标准项_默认做法?: 范_任何字典_凭某数据原项构建界面标准项_默认做法<
            范_该总机内所有字典_数据原项_可能的默认形态,
            范_该总机内所有字典_界面标准项_各形态之交集
        >;
    };
};





export function 构建字典群之总机 <
    范_该总机内所有字典_数据原项_可能的默认形态 = any,
    范_该总机内所有字典_界面标准项_各形态之交集 extends 范_界面标准项_最简形态 = 范_界面标准项_最简形态<any, any>
>(
    该字典群之总机之配置项总集?: 范_用以构建字典群之总机之配置项总集_准用形式<
        范_该总机内所有字典_数据原项_可能的默认形态,
        范_该总机内所有字典_界面标准项_各形态之交集
    >
): 范_字典群之总机<
    范_该总机内所有字典_数据原项_可能的默认形态,
    范_该总机内所有字典_界面标准项_各形态之交集
> {

    /** 此处定义该【范】是为了在本函数体方便指代。 */
    type 范_用以构建该字典群之总机之配置项总集_完备形式 = 范_用以构建字典群之总机之配置项总集_完备形式<
        范_该总机内所有字典_数据原项_可能的默认形态,
        范_该总机内所有字典_界面标准项_各形态之交集
    >;

    /** 此处定义该【范】是为了在本函数体方便指代。 */
    type 范_该字典群之总机 = 范_字典群之总机<
        范_该总机内所有字典_数据原项_可能的默认形态,
        范_该总机内所有字典_界面标准项_各形态之交集
    >;



    function 初始化 (强制重新初始化?: boolean): Promise<void> {
        const { 状态集 } = 该字典群之总机

        if (状态集.初始化任务仍在运转) {
            return 状态集.期待_初始化任务已完成
        }

        if (强制重新初始化 || !状态集.初始化任务已经成功) {
            状态集.初始化任务仍在运转 = true
            状态集.初始化任务已经成功 = false
            return 令所有字典按需重建数据('仅限从未构建过数据的的字典参与').then(() => {
                状态集.初始化任务仍在运转 = false
                状态集.初始化任务已经成功 = true
            })
        } else {
            return 状态集.期待_初始化任务已完成
        }
    }



    function 追加一批字典 <范_该组字典_数据原项_可能的默认形态 = 范_该总机内所有字典_数据原项_可能的默认形态>(
        用以构建一批字典机之配置项集之列表?: Array<
            范_用以构建单个字典机之配置项总集_准用形式<范_该组字典_数据原项_可能的默认形态, 范_该总机内所有字典_界面标准项_各形态之交集>
        >
    ): void {
        if (!Array.isArray(用以构建一批字典机之配置项集之列表)) { return }
        const { 按需追加单个字典 } = 该字典群之总机._幕后行为
        用以构建一批字典机之配置项集之列表.forEach(按需追加单个字典)
    }



    function 令所有字典按需重建数据 (
        本次执行须为哪些字典重建数据?: 范_字典群之总机成批重建字典的执行方案
    ): Promise<void> {

        // ----- 准备工作 -----

        if (
            typeof 本次执行须为哪些字典重建数据 !== 'string' ||
            !成批重建字典数据时之所有可能的方案.includes(本次执行须为哪些字典重建数据)
        ) {
            本次执行须为哪些字典重建数据 = '仅限从未构建过数据的的字典参与'
        }



        // ----- 确定须参与的字典之列表 -----

        let 须为其构建数据之字典机之列表 = 该字典群之总机.字典机之集.列表形式

        if (本次执行须为哪些字典重建数据 === '仅限从未构建过数据的的字典参与') {
            须为其构建数据之字典机之列表 = 须为其构建数据之字典机之列表.filter(
                某字典机 => !某字典机.状态集.在该字典所属的字典群初始化时不应获取或构建该字典的数据 && !某字典机.状态集.当下的数据系某次成功构建而得的
            )
        } else if (本次执行须为哪些字典重建数据 === '所有具备自动初始化特征的字典均参与') {
            须为其构建数据之字典机之列表 = 须为其构建数据之字典机之列表.filter(
                某字典机 => !某字典机.状态集.在该字典所属的字典群初始化时不应获取或构建该字典的数据
            )
        }



        // ----- 令所有参与的字典各自构建数据 -----

        return Promise.allSettled(
            须为其构建数据之字典机之列表.map(某字典机 => 某字典机.行为.重建数据())
        )
            .then(() => undefined)
            .catch(() => undefined)
    }



    function 取某字典机 <
        范_该字典_数据原项 = 范_该总机内所有字典_数据原项_可能的默认形态,
        范_该字典_界面标准项 extends 范_该总机内所有字典_界面标准项_各形态之交集 = 范_该总机内所有字典_界面标准项_各形态之交集
    >(
        欲索取之字典之唯一标识?: 范_字典之唯一标识
    ): (null | 范_字典机<范_该字典_数据原项, 范_该字典_界面标准项>) {
        if (!是字典之合规的唯一标识(欲索取之字典之唯一标识)) { return null }
        const 字典机之哈希表 = 该字典群之总机.字典机之集.哈希表形式
        const 字典机 = 字典机之哈希表[欲索取之字典之唯一标识!] as 范_字典机<范_该字典_数据原项, 范_该字典_界面标准项>
        return 字典机 || null
    }



    function 取某字典之界面标准项之列表 <
        范_该字典_数据原项 = 范_该总机内所有字典_数据原项_可能的默认形态,
        范_该字典_界面标准项 extends 范_该总机内所有字典_界面标准项_各形态之交集 = 范_该总机内所有字典_界面标准项_各形态之交集
    >(
        欲索取其中数据之字典之唯一标识?: 范_字典之唯一标识
    ): 范_界面标准项_之列表<范_该字典_界面标准项> {
        const 字典机 = 取某字典机<范_该字典_数据原项, 范_该字典_界面标准项>(欲索取其中数据之字典之唯一标识)
        if (字典机) {
            return 字典机.数据集.界面标准项集.列表形式
        } else {
            return []
        }
    }



    function 取某字典之界面标准项之哈希表 <
        范_该字典_数据原项 = 范_该总机内所有字典_数据原项_可能的默认形态,
        范_该字典_界面标准项 extends 范_该总机内所有字典_界面标准项_各形态之交集 = 范_该总机内所有字典_界面标准项_各形态之交集
    >(
        欲索取其中数据之字典之唯一标识?: 范_字典之唯一标识
    ): 范_界面标准项_之哈希表<范_该字典_界面标准项> {
        const 字典机 = 取某字典机<范_该字典_数据原项, 范_该字典_界面标准项>(欲索取其中数据之字典之唯一标识)
        if (字典机 && 字典机.数据集.界面标准项集.哈希表形式) {
            return 字典机.数据集.界面标准项集.哈希表形式
        } else {
            return {}
        }
    }



    function 按需追加单个字典 <
        范_该字典_数据原项 = 范_该总机内所有字典_数据原项_可能的默认形态,
        范_该字典_界面标准项 extends 范_该总机内所有字典_界面标准项_各形态之交集 = 范_该总机内所有字典_界面标准项_各形态之交集
    >(
        用以构建该字典机之配置项总集?: 范_用以构建单个字典机之配置项总集_准用形式<
            范_该字典_数据原项,
            范_该字典_界面标准项
        >
    ): (
        null | 范_字典机<范_该字典_数据原项, 范_该字典_界面标准项>
    ) {

        /** 此处定义该【范】是为了在本函数体方便指代。 */
        type 范_用以构建该字典机之配置项总集_准用形式 = 范_用以构建单个字典机之配置项总集_准用形式<
            范_该字典_数据原项,
            范_该字典_界面标准项
        >;



        if (!是合规的非列表对象(用以构建该字典机之配置项总集)) { return null }
        const 已知合规的配置项总集 = 求合规的非列表对象_按需构造空的对象<范_用以构建该字典机之配置项总集_准用形式>(用以构建该字典机之配置项总集)

        const { 该字典之唯一标识 } = 已知合规的配置项总集
        if (!是字典之合规的唯一标识(该字典之唯一标识)) { return null }
        const 已知合规的唯一标识: 范_字典之唯一标识 = 该字典之唯一标识 as 范_字典之唯一标识

        const 字典机 = 取某字典机<范_该字典_数据原项, 范_该字典_界面标准项>(已知合规的唯一标识)
        if (字典机) {
            console.warn(`不应重复构建标识为 “${已知合规的唯一标识}” 的【字典机】。已略过该构建任务。`)
            return 字典机
        }

        const 构建之结果 = 构建单个字典机<范_该字典_数据原项, 范_该字典_界面标准项>(
            已知合规的配置项总集,

            {
                任何字典_凭数据原项集构建诸数据映射表_默认做法,
                任何字典_凭某数据原项构建界面标准项_默认做法,
            },
        )

        if (!构建之结果) {
            return null
        }

        const 新构建的字典机 = 构建之结果

        const { 字典机之集 } = 该字典群之总机

        字典机之集.列表形式.push(新构建的字典机)
        字典机之集.哈希表形式[已知合规的唯一标识] = 新构建的字典机

        return 新构建的字典机
    }



    function 构建单个字典机 <
        范_该字典_数据原项 = 范_该总机内所有字典_数据原项_可能的默认形态,
        范_该字典_界面标准项 extends 范_该总机内所有字典_界面标准项_各形态之交集 = 范_该总机内所有字典_界面标准项_各形态之交集
    >(
        用以构建该字典机之配置项总集?: 范_用以构建单个字典机之配置项总集_准用形式<范_该字典_数据原项, 范_该字典_界面标准项>,

        默认值集?: {
            任何字典_凭数据原项集构建诸数据映射表_默认做法?: 范_任何字典_凭数据原项集构建诸数据映射表_默认做法<范_该总机内所有字典_数据原项_可能的默认形态, 范_该总机内所有字典_界面标准项_各形态之交集['值']>;
            任何字典_凭某数据原项构建界面标准项_默认做法?: 范_任何字典_凭某数据原项构建界面标准项_默认做法<范_该总机内所有字典_数据原项_可能的默认形态, 范_该总机内所有字典_界面标准项_各形态之交集>;
        }
    ): (
        null | 范_字典机<范_该字典_数据原项, 范_该字典_界面标准项>
    ) {

        /** 此处定义该【范】是为了在本函数体方便指代。 */
        type 范_用以构建该字典机之配置项总集_完备形式 = 范_用以构建单个字典机之配置项总集_完备形式<范_该字典_数据原项, 范_该字典_界面标准项>;

        /** 此处定义该【范】是为了在本函数体方便指代。 */
        type 范_该字典机 = 范_字典机<范_该字典_数据原项, 范_该字典_界面标准项>;

        /** 此处定义该【范】是为了在本函数体方便指代。 */
        type 范_该字典机所属总机提供的默认值集_准用形式 = {
            任何字典_凭数据原项集构建诸数据映射表_默认做法?: 范_任何字典_凭数据原项集构建诸数据映射表_默认做法<范_该总机内所有字典_数据原项_可能的默认形态, 范_该总机内所有字典_界面标准项_各形态之交集['值']>;
            任何字典_凭某数据原项构建界面标准项_默认做法?: 范_任何字典_凭某数据原项构建界面标准项_默认做法<范_该总机内所有字典_数据原项_可能的默认形态, 范_该总机内所有字典_界面标准项_各形态之交集>;
        };

        /** 此处定义该【范】是为了在本函数体方便指代。 */
        type 范_该字典_代表全选的字典项 = 范_某字典_代表全选的字典项<范_该字典_界面标准项>;

        /** 此处定义该【范】是为了在本函数体方便指代。 */
        type 范_该字典_代表全都不选的字典项 = 范_某字典_代表全都不选的字典项<范_该字典_界面标准项>;



        const {
            任何字典_凭数据原项集构建诸数据映射表_默认做法,
            任何字典_凭某数据原项构建界面标准项_默认做法,
        } = 求合规的非列表对象_按需构造空的对象<范_该字典机所属总机提供的默认值集_准用形式>(默认值集)



        const 已知合规的配置项总集 = 求合规的非列表对象_若不合规则给出null<范_用以构建该字典机之配置项总集_完备形式>(用以构建该字典机之配置项总集)
        if (!已知合规的配置项总集) {
            // 不必给出警示或出错提示。
            return null
        }

        const { 该字典之唯一标识: 待检测的唯一标识 } = 已知合规的配置项总集
        if (!是字典之合规的唯一标识(待检测的唯一标识)) {
            console.error('用以构建某字典之配置总集中：缺少合规的【\`待检测的唯一标识\`】。所涉配置项总集为：', 用以构建该字典机之配置项总集)
            return null
        }

        const 该字典之唯一标识: 范_字典之唯一标识 = 待检测的唯一标识 as 范_字典之唯一标识

        const 事件处理程序集 = 求合规的非列表对象_若不合规则给出null<范_用以构建该字典机之配置项总集_完备形式['事件处理程序集']>(已知合规的配置项总集['事件处理程序集'])
        if (!事件处理程序集) {
            console.error(`在用以构建字典 “${该字典之唯一标识}” 的配置项总集中：缺少合规的【\`事件处理程序集\`】对象。`)
            return null
        }



        const {
            构建或获取原始数据集,
        } = 事件处理程序集

        if (typeof 构建或获取原始数据集 !== 'function') {
            console.error(`在用以构建字典 “${该字典之唯一标识}” 的配置项总集中：【\`构建或获取原始数据集\`】不是函数。`)
            return null
        }



        const 配置项集 = 求合规的非列表对象_按需构造空的对象<范_用以构建该字典机之配置项总集_完备形式['配置项集']>(已知合规的配置项总集['配置项集'])

        let 该字典诸数据映射表之构建方案 = 配置项集.该字典诸数据映射表之构建方案
        if (
            typeof 该字典诸数据映射表之构建方案 !== 'string' ||
            !单个字典之诸数据映射表之所有可能的构建方案.includes(该字典诸数据映射表之构建方案)
        ) {
            该字典诸数据映射表之构建方案 = 单个字典之诸数据映射表之默认构建方案
        }

        const 外界须提供函数用以凭数据原项集构建诸数据映射表 = 该字典诸数据映射表之构建方案 === '从数据原项集中提取而得'
        const 外界须提供函数用以脱离数据原项集构建诸数据映射表 = ([
            '脱离数据原项集单独构建，一次性即可',
            '脱离数据原项集单独构建，且须反复获取或构建',
        ] as 范_单个字典之数据映射表之构建方案[]).includes(该字典诸数据映射表之构建方案)



        const 在该字典所属的字典群初始化时不应获取或构建该字典的数据 = !!配置项集.在该字典所属的字典群初始化时不应获取或构建该字典的数据
        const 应构建界面标准项之哈希表 = !!配置项集.应构建界面标准项之哈希表



        let 代表全选的字典项 = 求合规的非列表对象_若不合规则给出null<范_该字典_代表全选的字典项>(配置项集['代表全选的字典项'])
        if (代表全选的字典项) {
            const { 应位于候选列表之该处, 界面标准项 } = 代表全选的字典项

            if (!是合规的非列表对象(界面标准项)) {
                console.error(`在用以构建字典 “${该字典之唯一标识}” 的配置项总集中：【\`代表全选的字典项\`】为附带合规的【\'界面标准项\'】。`)
                代表全选的字典项 = null
            } else {
                if (![
                    '首部',
                    '尾部',
                ].includes(应位于候选列表之该处)) {
                    代表全选的字典项.应位于候选列表之该处 = '首部'
                }
            }
        }



        let 代表全都不选的字典项 = 求合规的非列表对象_若不合规则给出null<范_该字典_代表全都不选的字典项>(配置项集['代表全都不选的字典项'])
        if (代表全都不选的字典项) {
            const { 应位于候选列表之该处, 界面标准项 } = 代表全都不选的字典项

            if (!是合规的非列表对象(界面标准项)) {
                console.error(`在用以构建字典 “${该字典之唯一标识}” 的配置项总集中：【\`代表全都不选的字典项\`】为附带合规的【\'界面标准项\'】。`)
                代表全都不选的字典项 = null
            } else {
                if (![
                    '首部',
                    '尾部',
                ].includes(应位于候选列表之该处)) {
                    代表全都不选的字典项.应位于候选列表之该处 = '首部'
                }
            }
        }



        let { 脱离数据原项集构建诸数据映射表 } = 事件处理程序集

        if (外界须提供函数用以脱离数据原项集构建诸数据映射表) {
            if (typeof 脱离数据原项集构建诸数据映射表 !== 'function') {
                console.error(`在用以构建字典 “${该字典之唯一标识}” 的配置项总集中：【\`脱离数据原项集构建诸数据映射表\`】不是函数。`)
                return null
            }
        }



        let { 凭数据原项集构建诸数据映射表 } = 事件处理程序集

        if (外界须提供函数用以凭数据原项集构建诸数据映射表) {
            if (typeof 凭数据原项集构建诸数据映射表 !== 'function') {
                if (typeof 任何字典_凭数据原项集构建诸数据映射表_默认做法 === 'function') {
                    凭数据原项集构建诸数据映射表 = 任何字典_凭数据原项集构建诸数据映射表_默认做法 as unknown as 范_任何字典_凭数据原项集构建诸数据映射表_默认做法<范_该字典_数据原项, 范_该字典_界面标准项['值']>
                } else {
                    console.error(`在用以构建字典 “${该字典之唯一标识}” 的配置项总集中：【\`凭数据原项集构建诸数据映射表\`】和【\`任何字典_凭数据原项集构建诸数据映射表_默认做法\`】都不是函数。`)
                    return null
                }
            }
        }



        let { 凭某数据原项构建界面标准项 } = 事件处理程序集

        if (typeof 凭某数据原项构建界面标准项 !== 'function') {
            if (typeof 任何字典_凭某数据原项构建界面标准项_默认做法 === 'function') {
                凭某数据原项构建界面标准项 = 任何字典_凭某数据原项构建界面标准项_默认做法 as unknown as 范_任何字典_凭某数据原项构建界面标准项_默认做法<范_该字典_数据原项, 范_该字典_界面标准项>
            } else {
                console.error(`在用以构建字典 “${该字典之唯一标识}” 的配置项总集中：【\`凭某数据原项构建界面标准项\`】和【\`任何字典_凭某数据原项构建界面标准项_默认做法\`】都不是函数。`)
                return null
            }
        }





        function 凭数据原项集构建界面标准项集 (): void {
            const { 凭某数据原项构建界面标准项 } = 该字典机._事件处理程序集
            const { 数据原项集, 代表全选的字典项, 代表全都不选的字典项 } = 该字典机.数据集

            if (!Array.isArray(数据原项集)) { return }

            type 范_该字典_界面标准项集 = 范_该字典机['数据集']['界面标准项集']

            const 界面标准项之列表: 范_该字典_界面标准项集['列表形式'] = []
            const 界面标准项之哈希表: 范_该字典_界面标准项集['哈希表形式'] = {}

            if (代表全选的字典项) {
                const {
                    应位于候选列表之该处,
                    界面标准项,
                } = 代表全选的字典项

                if (应位于候选列表之该处 === '首部') {
                    界面标准项之列表.push(界面标准项)
                }
            }

            if (代表全都不选的字典项) {
                const {
                    应位于候选列表之该处,
                    界面标准项,
                } = 代表全都不选的字典项

                if (应位于候选列表之该处 === '首部') {
                    界面标准项之列表.push(界面标准项)
                }
            }

            数据原项集.forEach(某数据原项 => {
                const 界面标准项 = 凭某数据原项构建界面标准项(某数据原项)
                if (!界面标准项) { return }
                const { 唯一标识 } = 界面标准项
                if (!是字典之合规的唯一标识(唯一标识)) { return }

                界面标准项之列表.push(界面标准项)

                if (应构建界面标准项之哈希表) {
                    界面标准项之哈希表[唯一标识] = 界面标准项
                }
            })

            该字典机.数据集.界面标准项集.列表形式 = 界面标准项之列表
            该字典机.数据集.界面标准项集.哈希表形式 = 界面标准项之哈希表

            if (代表全都不选的字典项) {
                const {
                    应位于候选列表之该处,
                    界面标准项,
                } = 代表全都不选的字典项

                if (应位于候选列表之该处 === '尾部') {
                    界面标准项之列表.push(界面标准项)
                }
            }

            if (代表全选的字典项) {
                const {
                    应位于候选列表之该处,
                    界面标准项,
                } = 代表全选的字典项

                if (应位于候选列表之该处 === '尾部') {
                    界面标准项之列表.push(界面标准项)
                }
            }
        }



        function 按需构建诸数据映射表 (): Promise<void> {
            const { 状态集, 数据集, _事件处理程序集 } = 该字典机

            const {
                该字典诸数据映射表之构建方案,
                该字典诸数据映射表业已构建完毕,
            } = 状态集



            let 构建诸数据映射表一事已落实: Promise<void> = Promise.resolve()



            if (该字典诸数据映射表之构建方案 === '不必构建') {
                return 构建诸数据映射表一事已落实
            }



            if (该字典诸数据映射表之构建方案 === '从数据原项集中提取而得') {
                const {
                    数据原项集,
                } = 数据集

                const {
                    凭数据原项集构建诸数据映射表,
                } = _事件处理程序集

                if (!数据原项集) {
                    console.error(`字典 “${该字典之唯一标识}” 的诸【数据映射表】配置为 “${该字典诸数据映射表之构建方案}”。但构建诸【数据映射表】时，发现【\`数据原项集\`】尚不可用。`)
                    return 构建诸数据映射表一事已落实
                    // return Promise.reject()
                }

                if (typeof 凭数据原项集构建诸数据映射表 !== 'function') {
                    console.error(`字典 “${该字典之唯一标识}” 的诸【数据映射表】配置为 “${该字典诸数据映射表之构建方案}”。但构建诸【数据映射表】时，发现【\`凭数据原项集构建诸数据映射表\`】不是函数。`)
                    return 构建诸数据映射表一事已落实
                    // return Promise.reject()
                }

                return 凭数据原项集构建诸数据映射表(数据原项集).then(数据映射表集 => {
                    数据集.数据映射表集 = 数据映射表集
                    状态集.该字典诸数据映射表业已构建完毕 = true
                })
            }



            if (
                ([
                    '脱离数据原项集单独构建，一次性即可',
                    '脱离数据原项集单独构建，且须反复获取或构建',
                ] as 范_单个字典之数据映射表之构建方案[]
                ).includes(该字典诸数据映射表之构建方案)
            ) {
                if (该字典诸数据映射表之构建方案 === '脱离数据原项集单独构建，一次性即可' && 该字典诸数据映射表业已构建完毕) {
                    return 构建诸数据映射表一事已落实
                } else {
                    if (该字典诸数据映射表之构建方案 === '脱离数据原项集单独构建，且须反复获取或构建') {
                        状态集.该字典诸数据映射表业已构建完毕 = false
                    }
                }

                const {
                    脱离数据原项集构建诸数据映射表,
                } = _事件处理程序集

                if (typeof 脱离数据原项集构建诸数据映射表 !== 'function') {
                    console.error(`字典 “${该字典之唯一标识}” 的诸【数据映射表】配置为 “${该字典诸数据映射表之构建方案}”。但构建诸【数据映射表】时，发现【\`脱离数据原项集构建诸数据映射表\`】不是函数。`)
                    return 构建诸数据映射表一事已落实
                    // return Promise.reject()
                }

                return 脱离数据原项集构建诸数据映射表().then(数据映射表集 => {
                    数据集.数据映射表集 = 数据映射表集
                    状态集.该字典诸数据映射表业已构建完毕 = true
                })
            }



            return 构建诸数据映射表一事已落实
        }



        function 清空数据 (): void {
            const { 状态集, 数据集 } = 该字典机

            数据集.数据原项集 = null
            数据集.界面标准项集.列表形式 = []
            数据集.界面标准项集.哈希表形式 = {}
            数据集.数据映射表集.从值至界面措辞 = {}
            数据集.数据映射表集.从界面措辞至值 = {}

            状态集.当下的数据系某次成功构建而得的 = false
        }



        function 重建数据 (...用以获取数据原项集的参数表: any[]): Promise<void> {
            该字典机.行为.清空数据()

            const {
                该字典诸数据映射表之构建方案,
            } = 该字典机.状态集

            let 独立构建诸数据映射表一事已落实: Promise<void>
            if (
                ([
                    '脱离数据原项集单独构建，一次性即可',
                    '脱离数据原项集单独构建，且须反复获取或构建',
                ] as 范_单个字典之数据映射表之构建方案[]
                ).includes(该字典诸数据映射表之构建方案)
            ) {
                独立构建诸数据映射表一事已落实 = 该字典机._幕后行为.按需构建诸数据映射表()
            } else {
                独立构建诸数据映射表一事已落实 = Promise.resolve()
            }

            return Promise.all([
                独立构建诸数据映射表一事已落实,

                该字典机._事件处理程序集.构建或获取原始数据集(...用以获取数据原项集的参数表).then(数据原项集 => {
                    该字典机.数据集.数据原项集 = 数据原项集
                }),
            ]).then(() => {
                该字典机._幕后行为.凭数据原项集构建界面标准项集()
                该字典机.状态集.当下的数据系某次成功构建而得的 = true

                if (
                    ([
                        '从数据原项集中提取而得',
                    ] as 范_单个字典之数据映射表之构建方案[]
                    ).includes(该字典诸数据映射表之构建方案)
                ) {
                    return 该字典机._幕后行为.按需构建诸数据映射表()
                }
            })
        }

        function 求某项值之称谓 (项值?: any): string | null | undefined {
            if ([ null, undefined ].includes(项值)) {
                return 项值
            }

            const { 从值至界面措辞 } = 该字典机.数据集.数据映射表集
            let 查得的措辞: string | undefined
            查得的措辞 = 从值至界面措辞[`${项值}`]

            if (typeof 查得的措辞 === 'string') {
                return 查得的措辞
            }

            return `${项值}`
        }



        const 该字典机: 范_该字典机 = {
            该字典之唯一标识,

            状态集: {
                该字典诸数据映射表之构建方案,
                该字典诸数据映射表业已构建完毕: false,

                在该字典所属的字典群初始化时不应获取或构建该字典的数据,
                应构建界面标准项之哈希表,

                当下的数据系某次成功构建而得的: false,
            },

            数据集: {
                代表全选的字典项,
                代表全都不选的字典项,

                数据原项集: null,

                界面标准项集: {
                    列表形式: [],
                    哈希表形式: {},
                },

                数据映射表集: {
                    从值至界面措辞: {},
                    从界面措辞至值: {},
                },
            },

            行为: {
                清空数据,
                重建数据,
                求某项值之称谓,
            },

            _幕后行为: {
                凭数据原项集构建界面标准项集,
                按需构建诸数据映射表,
            },

            _事件处理程序集: {
                构建或获取原始数据集,
                脱离数据原项集构建诸数据映射表,
                凭数据原项集构建诸数据映射表,
                凭某数据原项构建界面标准项,
            },
        }

        return 该字典机
    }





    const 总机之已知合规的配置项总集 = 求合规的非列表对象_按需构造空的对象<范_用以构建该字典群之总机之配置项总集_完备形式>(该字典群之总机之配置项总集)

    const {
        不应自动初始化,
    } = 总机之已知合规的配置项总集

    let {
        任何字典_凭数据原项集构建诸数据映射表_默认做法,
        任何字典_凭某数据原项构建界面标准项_默认做法,
    } = 求合规的非列表对象_按需构造空的对象<范_用以构建该字典群之总机之配置项总集_完备形式['事件处理程序集']>(总机之已知合规的配置项总集.事件处理程序集)

    if (typeof 任何字典_凭数据原项集构建诸数据映射表_默认做法 !== 'function') {
        任何字典_凭数据原项集构建诸数据映射表_默认做法 = undefined
    }

    if (typeof 任何字典_凭某数据原项构建界面标准项_默认做法 !== 'function') {
        任何字典_凭某数据原项构建界面标准项_默认做法 = undefined
    }



    const 该字典群之总机: 范_该字典群之总机 = {
        字典机之集: {
            列表形式: [],
            哈希表形式: {},
        },

        状态集: {
            期待_初始化任务已完成: Promise.resolve(),
            初始化任务仍在运转: false,
            初始化任务已经成功: false,
        },

        行为: {
            初始化,
            追加一批字典,
            取某字典机,
            取某字典之界面标准项之列表,
            取某字典之界面标准项之哈希表,
            令所有字典按需重建数据,
        },

        _幕后行为: {
            按需追加单个字典,
        },

        _事件处理程序集: {
            任何字典_凭数据原项集构建诸数据映射表_默认做法,
            任何字典_凭某数据原项构建界面标准项_默认做法,
        },
    }



    追加一批字典(总机之已知合规的配置项总集.最初的一批用以构建字典机的配置项集之列表)



    if (!不应自动初始化) {
        该字典群之总机.状态集.期待_初始化任务已完成 = 初始化()
    }



    return 该字典群之总机
}
