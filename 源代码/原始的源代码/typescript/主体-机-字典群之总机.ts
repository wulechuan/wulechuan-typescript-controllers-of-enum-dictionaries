import type {
    范_字典机系统_This之默认式,

    范_期待_用以落实之之函数,
    范_期待_用以落空之之函数,

    范_字典_唯一标识,
    范_字典条目之视式_最简式,
    范_字典诸条目之视式_其列表,
    范_字典诸条目之视式_其哈希表,

    范_字典机,
    范_字典机_形制要求总集_准用式,

    范_字典群之总机,
    范_字典群之总机_形制要求总集_准用式,
    范_字典群之总机_成批重建字典数据之方案,
} from '@wulechuan/controllers-of-enum-dictionaries'

import {
    是合规的非列表对象,
    求合规的非列表对象_若不合规则给出null,
    求合规的非列表对象_若不合规则给出空的对象,
} from './辅助工具集-通用'

import {
    是字典之合规的唯一标识,
    // 是字典数据项之合规的唯一标识,
} from './辅助工具集-字典机专用'

import {
    作一字典机,
} from './主体-机-单个字典机'





export const 成批重建字典数据时之所有可能的方案: Array<范_字典群之总机_成批重建字典数据之方案> = [
    '仅限那些允许参与数据自动构建任务且尚未构建过数据的字典参与',
    '所有允许参与数据自动构建任务的字典均参与，不论其是否已构建好数据',
    '强制一切字典参与，不论其是否已构建好数据',
];





export function 为某字典群作总机 <
    范_该总机_this = 范_字典机系统_This之默认式,
    范_该总机内所有字典_条目原式_可能的默认形态 = any,
    范_该总机内所有字典_条目视式_各色形态之交集 extends 范_字典条目之视式_最简式 = 范_字典条目之视式_最简式<any>
>(
    this: 范_该总机_this,

    该字典群之总机之形制要求总集?: 范_字典群之总机_形制要求总集_准用式<
        范_该总机_this,
        范_该总机内所有字典_条目原式_可能的默认形态,
        范_该总机内所有字典_条目视式_各色形态之交集
    >
): 范_字典群之总机<
    范_该总机_this,
    范_该总机内所有字典_条目原式_可能的默认形态,
    范_该总机内所有字典_条目视式_各色形态之交集
> {

    /**
     * 定义以下诸【范】，是为了在本函数体中方便指代它们。
     */

    /** */

    type 范_该字典群之总机 = 范_字典群之总机<
        范_该总机_this,
        范_该总机内所有字典_条目原式_可能的默认形态,
        范_该总机内所有字典_条目视式_各色形态之交集
    >;



    type 范_该字典群之总机_形制要求总集_准用式 = 范_字典群之总机_形制要求总集_准用式<
        范_该总机_this,
        范_该总机内所有字典_条目原式_可能的默认形态,
        范_该总机内所有字典_条目视式_各色形态之交集
    >;



    type 范_该字典群之总机_诸事之应对_准用式_尚未绑定this = Partial<
        范_字典群之总机_范之零件_诸事之应对_完备式<
            范_该总机内所有字典_条目原式_可能的默认形态,
            范_该总机内所有字典_条目视式_各色形态之交集,
            范_常量_外界给出的配置集中的this
        >
    >;



    type 范_该字典群之总机_构建某字典机时用到的默认值集_完备式 = {

        /** 即便是在所谓【完备式】中，该项亦可省略。 */
        内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法?:
            范_某字典群_内内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法<
                范_该总机内所有字典_条目原式_可能的默认形态,
                范_该总机内所有字典_条目视式_各色形态之交集['值'],
                范_this_待定
            >;

        /** 即便是在所谓【完备式】中，该项亦可省略。 */
        内任何所谓标准字典_凭某条目之原式构建其视式_默认做法?:
            范_某字典群_内内任何所谓标准字典_凭某条目之原式构建其视式_默认做法<
                范_该总机内所有字典_条目原式_可能的默认形态,
                范_该总机内所有字典_条目视式_各色形态之交集,
                范_this_待定
            >;
    };





    let $_该字典群之总机_以往数据重建任务总次数 = 0
    let $_该字典群之总机_期待_所有批次的数据重建任务均已完毕_落实: undefined | 范_期待_用以落实之之函数<void>
    let $_该字典群之总机_期待_所有批次的数据重建任务均已完毕_落空: undefined | 范_期待_用以落空之之函数<void>
    let $_该字典群之总机_期待_迄今历次数据重建任务主体均已完成: null | Promise<void>
    let $_该字典群之总机_迄今所有批次任务中遭遇的所有异常_其列表: Array<any>;





    const 追加一批字典 = <范_该组字典_条目原式_可能的默认形态 = 范_该总机内所有字典_条目原式_可能的默认形态>(
        一批字典机之形制要求总集之列表?: Array<
            范_字典机_形制要求总集_准用式<
                范_该组字典_条目原式_可能的默认形态,
                范_该总机内所有字典_条目视式_各色形态之交集,
                范_常量_外界给出的配置集中的this
            >
        >
    ): void => {
        if (!Array.isArray(一批字典机之形制要求总集之列表)) { return }
        一批字典机之形制要求总集之列表.forEach(_该字典群之总机_按需追加单个字典)
        令所有字典按需重建数据('仅限那些允许参与数据自动构建任务且尚未构建过数据的字典参与')
    }



    const 删除一批字典 = (
        欲删除之诸字典之唯一标识之列表?: 范_字典_唯一标识[]
    ): void => {
        if (
            !Array.isArray(欲删除之诸字典之唯一标识之列表) ||
            欲删除之诸字典之唯一标识之列表.length === 0
        ) { return }

        const { 字典机群 } = 该字典群之总机.所持

        const {
            其列表: 字典机之旧列表,
            其哈希表: 字典机之旧哈希表,
        } = 字典机群

        let 字典机之新哈希表: typeof 字典机之旧哈希表 = {}

        let 字典机之新列表 = [ ...字典机之旧列表 ].filter(某字典机 => {
            const 该字典应销毁 = 欲删除之诸字典之唯一标识之列表.includes(某字典机.该字典之唯一标识)

            const 自毁 = 某字典机.为.自毁 as (this: unknown) => void

            if (该字典应销毁) {
                自毁()
            } else {
                字典机之新哈希表[某字典机.该字典之唯一标识] = 某字典机
            }

            return !该字典应销毁
        })

        字典机群.其列表 = 字典机之新列表
        字典机群.其哈希表 = 字典机之新哈希表
    }



    const 令所有字典按需重建数据 = (
        本次执行须为哪些字典重建数据?: 范_字典群之总机_成批重建字典数据之方案
    ): Promise<void> => {

        // ══════════ 准备工作 ════════════

        if (
            typeof 本次执行须为哪些字典重建数据 !== 'string' ||
            !成批重建字典数据时之所有可能的方案.includes(本次执行须为哪些字典重建数据)
        ) {
            本次执行须为哪些字典重建数据 = '仅限那些允许参与数据自动构建任务且尚未构建过数据的字典参与'
        }



        // ══════════ 确定须参与的字典之列表 ════════════

        let 须为其构建数据之字典机之列表 = 该字典群之总机.所持.字典机群.其列表

        if (本次执行须为哪些字典重建数据 === '仅限那些允许参与数据自动构建任务且尚未构建过数据的字典参与') {
            须为其构建数据之字典机之列表 = 须为其构建数据之字典机之列表.filter(
                某字典机 => !某字典机.形制要求杂集.该字典在默认情形下不参与字典群总机发起的数据重建任务 && !某字典机.态.当下的数据系某次成功构建而得的
            )
        } else if (本次执行须为哪些字典重建数据 === '所有允许参与数据自动构建任务的字典均参与，不论其是否已构建好数据') {
            须为其构建数据之字典机之列表 = 须为其构建数据之字典机之列表.filter(
                某字典机 => !某字典机.形制要求杂集.该字典在默认情形下不参与字典群总机发起的数据重建任务
            )
        }



        // ══════════ 令所有参与的字典各自构建数据 ════════════

        const 本批次任务之代号 = $_该字典群之总机_以往数据重建任务总次数 + 1

        // eslint-disable-next-line no-unused-vars
        const 本批次任务之消息前缀 = `${$_该字典群之总机_消息前缀2} 任务代号〔${本批次任务之代号}〕：`

        // console.debug('须为其构建数据之字典机之列表', 须为其构建数据之字典机之列表.map(字典机 => 字典机.该字典之唯一标识))



        $_该字典群之总机_以往数据重建任务总次数 += 1

        if (须为其构建数据之字典机之列表.length === 0) {
            return Promise.resolve()
        }



        const { 态 } = 该字典群之总机



        态.当下仍有字典机在构建数据 = true

        const 期待_本批次字典机之数据重建任务均已完成: Promise<void> = Promise.allSettled(
            须为其构建数据之字典机之列表.map(某字典机 => {
                const { 重建数据 } = 某字典机.为
                return (重建数据 as (this: unknown) => void)()
            })
        )
            .then(() => {})
            .catch(异常之记载 => {
                $_该字典群之总机_迄今所有批次任务中遭遇的所有异常_其列表.push(异常之记载)
            })



        const 发起本批次任务之前没有未完成的以往批次: boolean = !$_该字典群之总机_期待_迄今历次数据重建任务主体均已完成



        let 期待_含本批次任务在内的所有任务刚好完成: Promise<void>

        if (发起本批次任务之前没有未完成的以往批次) {
            $_该字典群之总机_迄今所有批次任务中遭遇的所有异常_其列表 = []

            态.期待_迄今所有批次的字典机之数据重建任务均已完成 = new Promise((落实, 落空) => {
                $_该字典群之总机_期待_所有批次的数据重建任务均已完毕_落实 = 落实
                $_该字典群之总机_期待_所有批次的数据重建任务均已完毕_落空 = 落空
            }).then(() => {
                态.当下仍有字典机在构建数据 = false
                $_该字典群之总机_期待_所有批次的数据重建任务均已完毕_落实 = undefined
                $_该字典群之总机_期待_所有批次的数据重建任务均已完毕_落空 = undefined
                态.期待_迄今所有批次的字典机之数据重建任务均已完成 = Promise.resolve()
            }).catch(异常之记载 => {
                态.当下仍有字典机在构建数据 = false
                $_该字典群之总机_期待_所有批次的数据重建任务均已完毕_落实 = undefined
                $_该字典群之总机_期待_所有批次的数据重建任务均已完毕_落空 = undefined
                态.期待_迄今所有批次的字典机之数据重建任务均已完成 = Promise.resolve()
                return Promise.reject($_该字典群之总机_迄今所有批次任务中遭遇的所有异常_其列表)
            })



            期待_含本批次任务在内的所有任务刚好完成 = 期待_本批次字典机之数据重建任务均已完成
        } else {
            期待_含本批次任务在内的所有任务刚好完成 = Promise.all([
                $_该字典群之总机_期待_迄今历次数据重建任务主体均已完成,
                期待_本批次字典机之数据重建任务均已完成,
            ]).then(() => {})
        }



        期待_含本批次任务在内的所有任务刚好完成 = 期待_含本批次任务在内的所有任务刚好完成.then(() => {
            // console.debug(`${本批次任务之消息前缀} 刚刚完成某批次数据重建任务。`)

            if ($_该字典群之总机_期待_迄今历次数据重建任务主体均已完成 !== 期待_含本批次任务在内的所有任务刚好完成) {
                // console.debug(`${本批次任务之消息前缀} 仍有某批次数据重建任务未完成。`)
                return
            } else {
                // console.debug(`${本批次任务之消息前缀} 已完成所有迄今所有批次的数据重建任务。`)
            }

            if ($_该字典群之总机_迄今所有批次任务中遭遇的所有异常_其列表.length === 0) {
                if (typeof $_该字典群之总机_期待_所有批次的数据重建任务均已完毕_落实 === 'function') {
                    $_该字典群之总机_期待_所有批次的数据重建任务均已完毕_落实()
                }
            } else {
                if (typeof $_该字典群之总机_期待_所有批次的数据重建任务均已完毕_落空 === 'function') {
                    $_该字典群之总机_期待_所有批次的数据重建任务均已完毕_落空()
                }
            }
        })

        $_该字典群之总机_期待_迄今历次数据重建任务主体均已完成 = 期待_含本批次任务在内的所有任务刚好完成



        return 期待_本批次字典机之数据重建任务均已完成
    }



    const 取某字典机 = <
        范_该字典_条目原式 = 范_该总机内所有字典_条目原式_可能的默认形态,
        范_该字典_条目视式 extends 范_该总机内所有字典_条目视式_各色形态之交集 = 范_该总机内所有字典_条目视式_各色形态之交集
    >(
        欲索取之字典_其唯一标识?: 范_字典_唯一标识
    ): (
        null | 范_字典机<范_该总机_this, 范_该字典_条目原式, 范_该字典_条目视式>
    ) => {
        if (!是字典之合规的唯一标识(欲索取之字典_其唯一标识)) { return null }
        const 字典机之哈希表 = 该字典群之总机.所持.字典机群.其哈希表
        const 字典机 = 字典机之哈希表[欲索取之字典_其唯一标识] as 范_字典机<范_该总机_this, 范_该字典_条目原式, 范_该字典_条目视式>
        return 字典机 || null
    }



    const 取某字典诸条目之视式_其列表 = <
        范_该字典_条目原式 = 范_该总机内所有字典_条目原式_可能的默认形态,
        范_该字典_条目视式 extends 范_该总机内所有字典_条目视式_各色形态之交集 = 范_该总机内所有字典_条目视式_各色形态之交集
    >(
        所涉字典_其唯一标识?: 范_字典_唯一标识
    ): 范_字典诸条目之视式_其列表<范_该字典_条目视式> => {
        const 字典机 = 取某字典机<范_该字典_条目原式, 范_该字典_条目视式>(所涉字典_其唯一标识)
        if (字典机) {
            return 字典机.所持.该字典诸条目之视式.其列表
        } else {
            return []
        }
    }



    const 取某字典诸条目之视式_其哈希表 = <
        范_该字典_条目原式 = 范_该总机内所有字典_条目原式_可能的默认形态,
        范_该字典_条目视式 extends 范_该总机内所有字典_条目视式_各色形态之交集 = 范_该总机内所有字典_条目视式_各色形态之交集
    >(
        所涉字典_其唯一标识?: 范_字典_唯一标识
    ): 范_字典诸条目之视式_其哈希表<范_该字典_条目视式> => {
        const 字典机 = 取某字典机<范_该字典_条目原式, 范_该字典_条目视式>(所涉字典_其唯一标识)
        if (字典机 && 字典机.所持.该字典诸条目之视式.其哈希表) {
            return 字典机.所持.该字典诸条目之视式.其哈希表
        } else {
            return {}
        }
    }



    const _该字典群之总机_按需追加单个字典 = <
        范_该字典_条目原式 = 范_该总机内所有字典_条目原式_可能的默认形态,
        范_该字典_条目视式 extends 范_该总机内所有字典_条目视式_各色形态之交集 = 范_该总机内所有字典_条目视式_各色形态之交集
    >(
        该字典机之形制要求总集?: 范_字典机_形制要求总集_准用式<
            范_该总机_this,
            范_该字典_条目原式,
            范_该字典_条目视式
        >
    ): (
        null | 范_字典机<范_该总机_this, 范_该字典_条目原式, 范_该字典_条目视式>
    ) => {

        if (!是合规的非列表对象(该字典机之形制要求总集)) { return null }
        const 已知合规的形制要求总集 = 该字典机之形制要求总集

        const { 该字典之唯一标识 } = 已知合规的形制要求总集
        if (!是字典之合规的唯一标识(该字典之唯一标识)) { return null }

        const 字典机 = 取某字典机<范_该字典_条目原式, 范_该字典_条目视式>(该字典之唯一标识)
        if (字典机) {
            console.debug(`${$_该字典群之总机_消息前缀2}\n    不应重复构建标识为 “${该字典之唯一标识}” 的【字典机】。已略过该构建任务。`)
            return 字典机
        }

        const 构建之结果 = 作一字典机<范_该字典群之总机, 范_该总机_this, 范_该字典_条目原式, 范_该字典_条目视式>(
            该字典群之总机,
            已知合规的形制要求总集
        )

        if (!构建之结果) {
            return null
        }

        const 新构建的字典机 = 构建之结果

        const { 字典机群 } = 该字典群之总机.所持

        字典机群.其列表.push(新构建的字典机)
        字典机群.其哈希表[该字典之唯一标识] = 新构建的字典机

        return 新构建的字典机
    }



    const _该字典群之总机_发布消息_单个字典之数据已重建 = (
        所涉字典机: 范_字典机<范_该总机_this, any, 范_该总机内所有字典_条目视式_各色形态之交集>
    ): void => {
        if (typeof 任何字典_某次数据重建后 === 'function') {
                return (任何字典_某次数据重建后 as (
                    this: unknown,
                    该字典群之总机: 范_字典群之总机<范_该总机_this, 范_该总机内所有字典_条目原式_可能的默认形态, 范_该总机内所有字典_条目视式_各色形态之交集>,
                    所涉字典机: 范_字典机<范_该总机_this, any, 范_该总机内所有字典_条目视式_各色形态之交集>
                ) => void)(该字典群之总机, 所涉字典机)
        }
    }





    const 总机之已知合规的形制要求总集 = 求合规的非列表对象_若不合规则给出空的对象<范_该字典群之总机_形制要求总集_准用式_尚未绑定this>(该字典群之总机之形制要求总集)

    let {
        该字典群之称谓,
    } = 总机之已知合规的形制要求总集

    if (typeof 该字典群之称谓 !== 'string' || !该字典群之称谓.trim()) {
        该字典群之称谓 = '<未详>'
    } else {
        该字典群之称谓 = 该字典群之称谓 // .trim()
    }



    const 该总机_诸事之应对_尚未绑定this = 求合规的非列表对象_若不合规则给出空的对象<范_该字典群之总机_诸事之应对_准用式_尚未绑定this>(
        总机之已知合规的形制要求总集['诸事之应对']
    )

    const {
        内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法: 内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法_尚未绑定this,
        内任何所谓标准字典_凭某条目之原式构建其视式_默认做法: 内任何所谓标准字典_凭某条目之原式构建其视式_默认做法_尚未绑定this,
        任何字典_某次数据重建后: 任何字典_某次数据重建后_尚未绑定this,
    } = 该总机_诸事之应对_尚未绑定this



    let 内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法: 范_该字典群之总机_诸事之应对_完备式_已绑定this['内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法'] = undefined

    if (typeof 内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法_尚未绑定this === 'function') {
        内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法 = (
            内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法_尚未绑定this as OmitThisParameter<
                typeof 内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法_尚未绑定this
            >
        ).bind(this)
    } else {
        内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法 = undefined
    }



    let 内任何所谓标准字典_凭某条目之原式构建其视式_默认做法: 范_该字典群之总机_诸事之应对_完备式_已绑定this['内任何所谓标准字典_凭某条目之原式构建其视式_默认做法'] = undefined

    if (typeof 内任何所谓标准字典_凭某条目之原式构建其视式_默认做法_尚未绑定this === 'function') {
        内任何所谓标准字典_凭某条目之原式构建其视式_默认做法 = (
            内任何所谓标准字典_凭某条目之原式构建其视式_默认做法_尚未绑定this as OmitThisParameter<
                typeof 内任何所谓标准字典_凭某条目之原式构建其视式_默认做法_尚未绑定this
            >
        ).bind(this)
    } else {
        内任何所谓标准字典_凭某条目之原式构建其视式_默认做法 = undefined
    }



    let 任何字典_某次数据重建后: 范_该字典群之总机_诸事之应对_完备式_已绑定this['任何字典_某次数据重建后'] = undefined

    if (typeof 任何字典_某次数据重建后_尚未绑定this === 'function') {
        任何字典_某次数据重建后 = (
            任何字典_某次数据重建后_尚未绑定this as OmitThisParameter<
                typeof 任何字典_某次数据重建后_尚未绑定this
            >
        ).bind(this)
    } else {
        任何字典_某次数据重建后 = undefined
    }



    const $_该字典群之总机_消息前缀 = `【字典总机】“${该字典群之称谓}”`
    const $_该字典群之总机_消息前缀2 = `【字典总机】“${该字典群之称谓}”：`



    const 该字典群之总机: 范_该字典群之总机 = {
        该字典群之称谓,

        所持: {
            字典机群: {
                其列表: [],
                其哈希表: {},
            },
        },

        态: {
            当下仍有字典机在构建数据: false,
            期待_迄今所有批次的字典机之数据重建任务均已完成: Promise.resolve(),
        },

        为: {
            追加一批字典,
            删除一批字典,
            取某字典机,
            取某字典诸条目之视式_其列表,
            取某字典诸条目之视式_其哈希表,
            令所有字典按需重建数据,
        },

        应对: {
            内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法,
            内任何所谓标准字典_凭某条目之原式构建其视式_默认做法,
            任何字典_某次数据重建后,
        },
    }



    追加一批字典(总机之已知合规的形制要求总集.第一批字典机形制要求总集_其列表)



    return 该字典群之总机
}
