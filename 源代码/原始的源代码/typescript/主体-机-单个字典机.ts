// import type {
//     范_某期待_用以落实之之函数,
//     范_某期待_用以落空之之函数,
// } from '../types/共'

// import type {
//     范_字典条目之视式_最简式,
//     范_字典_字典特别条目_其代表全选者_形参准用式,
//     范_字典_字典特别条目_其代表全选者_完备式,
//     范_字典_字典特别条目_其代表全都不选者_形参准用式,
//     范_字典_字典特别条目_其代表全都不选者_完备式,
// } from '../types/料-字典'

// import type {
//     范_单个字典构建诸字典条目内容映射表之方案,

//     范_字典机,
//     范_字典机_形制要求总集_形参准用式,
//     范_字典机_范之零件_所持_形参准用式,
//     范_字典机_范之零件_形制要求杂集_形参准用式,
//     范_字典机_范之零件_诸事之应对_形参准用式,
//     范_字典机_范之零件_诸事之应对_完备式,

//     // 范_某字典群_内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法,
//     // 范_某字典群_内任何所谓标准字典_凭某条目之原式构建其视式_默认做法,
// } from '../types/机-单个字典机'

// import type {
//     范_字典群之总机,
// } from '../types/机-字典群之总机'

import type {
    范_某期待_用以落实之之函数,
    范_某期待_用以落空之之函数,

    范_字典条目之视式_最简式,
    范_字典_字典特别条目_其代表全选者_形参准用式,
    范_字典_字典特别条目_其代表全选者_完备式,
    范_字典_字典特别条目_其代表全都不选者_形参准用式,
    范_字典_字典特别条目_其代表全都不选者_完备式,

    范_单个字典构建诸字典条目内容映射表之方案,

    范_字典机,
    范_字典机_形制要求总集_形参准用式,
    范_字典机_范之零件_所持_形参准用式,
    范_字典机_范之零件_形制要求杂集_形参准用式,
    范_字典机_范之零件_诸事之应对_形参准用式,
    范_字典机_范之零件_诸事之应对_完备式,

    // 范_某字典群_内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法,
    // 范_某字典群_内任何所谓标准字典_凭某条目之原式构建其视式_默认做法,

    范_字典群之总机,
} from '@wulechuan/controllers-of-enum-dictionaries'





import {
    是合规的非列表对象,
    求合规的非列表对象_若不合规则给出null,
    求合规的非列表对象_若不合规则给出空的对象,
} from './辅助工具集-通用'

import {
    是字典之合规的唯一标识,
    是合规的字典群之总机之实例,
} from './辅助工具集-字典机专用'





export const 单个字典构建诸字典条目内容映射表时之各色候选方案: Array<范_单个字典构建诸字典条目内容映射表之方案> = [
    '不必构建',
    '从该字典之诸条目原式之集提取而得',
    '脱离该字典之诸条目原式之集而构建，仅一次即可',
    '脱离该字典之诸条目原式之集而构建，且须反复获取或构建',
]

export const 单个字典构建诸字典条目内容映射表时之默认方案: 范_单个字典构建诸字典条目内容映射表之方案 = '从该字典之诸条目原式之集提取而得';

export const 字典特别条目_其代表全选者_默认的呈示称谓 = '〔全选〕'

export const 字典特别条目_其代表全都不选者_默认的呈示称谓 = '〔全都不选〕'





/**
 * ═══════════════════════════════════════════════════════════════════════════════
 *           工厂函数【作一字典机】
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/** */

export function 作一字典机<
    范_该字典机_其This,
    范_所属总机_内所谓标准字典_条目原式 = any,
    范_所属总机_内所有字典_条目视式_各色形态之交集 extends 范_字典条目之视式_最简式 = 范_字典条目之视式_最简式<any>,
    范_该字典_条目原式 = 范_所属总机_内所谓标准字典_条目原式,
    范_该字典_条目视式 extends 范_所属总机_内所有字典_条目视式_各色形态之交集 = 范_所属总机_内所有字典_条目视式_各色形态之交集,
> (
    this: 范_该字典机_其This,

    所属字典群之总机?:
        范_字典群之总机<
            范_该字典机_其This,
            范_所属总机_内所谓标准字典_条目原式,
            范_所属总机_内所有字典_条目视式_各色形态之交集
        >,

    该字典机之形制要求总集?:
        范_字典机_形制要求总集_形参准用式<
            范_该字典机_其This,
            范_该字典_条目原式,
            范_该字典_条目视式
        >
): (
    null | 范_字典机<范_该字典机_其This, 范_该字典_条目原式, 范_该字典_条目视式>
) {

    /**
    * 定义以下诸【范】，是为了在本函数体中方便指代它们。
    */

    /** */

    type 范_该字典机 = 范_字典机<
        范_该字典机_其This,
        范_该字典_条目原式,
        范_该字典_条目视式
    >;

    type 范_该字典机_形制要求总集_形参准用式 = 范_字典机_形制要求总集_形参准用式<
        范_该字典机_其This,
        范_该字典_条目原式,
        范_该字典_条目视式
    >;

    type 范_该字典机_诸事之应对_形参准用式 = 范_字典机_范之零件_诸事之应对_形参准用式<
        范_该字典机_其This,
        范_该字典_条目原式,
        范_该字典_条目视式
    >;

    type 范_该字典机_诸事之应对_完备式 = 范_字典机_范之零件_诸事之应对_完备式<
        范_该字典机_其This,
        范_该字典_条目原式,
        范_该字典_条目视式
    >;

    type 范_该字典机_形制要求杂集_形参准用式 = 范_字典机_范之零件_形制要求杂集_形参准用式<
        范_该字典机_其This
    >;



    type 范_该字典_范之零件_所持_形参准用式 = 范_字典机_范之零件_所持_形参准用式<
        范_该字典机_其This,
        范_该字典_条目原式,
        范_该字典_条目视式
    >;

    type 范_该字典_字典特别条目_其代表全选者_形参准用式 = 范_字典_字典特别条目_其代表全选者_形参准用式<范_该字典_条目视式>;
    type 范_该字典_字典特别条目_其代表全选者_完备式 = 范_字典_字典特别条目_其代表全选者_完备式<范_该字典_条目视式>;

    type 范_该字典_字典特别条目_其代表全都不选者_形参准用式 = 范_字典_字典特别条目_其代表全都不选者_形参准用式<范_该字典_条目视式>;
    type 范_该字典_字典特别条目_其代表全都不选者_完备式 = 范_字典_字典特别条目_其代表全都不选者_完备式<范_该字典_条目视式>;





    let $_该字典机已销毁: boolean = false
    let $_该字典机_期待_最末一次数据重构_落实之: undefined | 范_某期待_用以落实之之函数<void>
    let $_该字典机_期待_最末一次数据重构_落空之: undefined | 范_某期待_用以落空之之函数<void>





    if (!是合规的字典群之总机之实例(所属字典群之总机)) {
        console.error(
            `构建某【字典机】时，第一个实参（【\`所属字典群之总机\`】）不合规。合规的第一实参应为【\`范_所属字典群之总机<this, T1, T2>\`】。\n   `,
            '给出的第一个实参为：', 所属字典群之总机
        )

        return null
    }

    const {
        该字典群之称谓: 所属字典群之称谓,
    } = 所属字典群之总机

    const {
        内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法: 所属字典群_内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法,
        内任何所谓标准字典_凭某条目之原式构建其视式_默认做法: 所属字典群_内任何所谓标准字典_凭某条目之原式构建其视式_默认做法,
        内任何字典_某次数据重建后_统一做法: 所属字典群_内任何字典_某次数据重建后_统一做法,
    } = 所属字典群之总机.应对



    const 已知合规的形制要求总集 = 求合规的非列表对象_若不合规则给出null<范_该字典机_形制要求总集_形参准用式>(
        该字典机之形制要求总集
    )

    if (!已知合规的形制要求总集) {
        // 此种情形不必给出警示或出错提示。
        return null
    }





    const { 该字典之唯一标识 } = 已知合规的形制要求总集
    if (!是字典之合规的唯一标识(该字典之唯一标识)) {
        console.error(
            `${所属字典群之称谓}：\n    用以构建某【字典机】之【形制要求总集】中：缺少合规的【\`该字典之唯一标识\`】。\n   `,
            '所涉【形制要求总集】为：', 该字典机之形制要求总集
        )

        return null
    }



    const {
        该字典机的调试信息之详尽等级: _该字典机的调试信息之详尽等级_外界给出值,
    } = 已知合规的形制要求总集

    let 该字典机的调试信息之详尽等级 = 0
    if (typeof _该字典机的调试信息之详尽等级_外界给出值 === 'number') {
        该字典机的调试信息之详尽等级 = _该字典机的调试信息之详尽等级_外界给出值
    }



    const $_该字典机_消息前缀 = `${所属字典群之称谓} -> 【字典机】“${该字典之唯一标识}”：\n   `



    const 诸事之应对 = 求合规的非列表对象_若不合规则给出null<范_该字典机_诸事之应对_形参准用式>(
        已知合规的形制要求总集['诸事之应对']
    )

    if (!诸事之应对) {
        console.error(`${$_该字典机_消息前缀} 在用以构建该【字典机】的【形制要求总集】中：缺少合规的【\`诸事之应对\`】对象。`)
        return null
    }



    // ══════════ 开始处理外界给出的【形制要求杂集】 ════════════

    const 形制要求杂集 = 求合规的非列表对象_若不合规则给出空的对象<范_该字典机_形制要求杂集_形参准用式>(已知合规的形制要求总集['形制要求杂集'])

    let 该字典构建诸字典条目内容映射表之方案 = 形制要求杂集.该字典构建诸字典条目内容映射表之方案
    if (
        typeof 该字典构建诸字典条目内容映射表之方案 !== 'string' ||
        !单个字典构建诸字典条目内容映射表时之各色候选方案.includes(该字典构建诸字典条目内容映射表之方案)
    ) {
        该字典构建诸字典条目内容映射表之方案 = 单个字典构建诸字典条目内容映射表时之默认方案
    }

    const 该字典在默认情形下不参与字典群总机发起的数据重建任务 = !!形制要求杂集.该字典在默认情形下不参与字典群总机发起的数据重建任务
    const 应构建字典条目之视式之哈希表 = !!形制要求杂集.应构建字典条目之视式之哈希表

    const 该字典构建诸字典条目内容映射表之方案_甲组: 范_单个字典构建诸字典条目内容映射表之方案[] = [
        '脱离该字典之诸条目原式之集而构建，仅一次即可',
        '脱离该字典之诸条目原式之集而构建，且须反复获取或构建',
    ]

    const 该字典构建诸字典条目内容映射表之方案_乙组: 范_单个字典构建诸字典条目内容映射表之方案[] = [
        '从该字典之诸条目原式之集提取而得',
    ]

    const 外界须提供函数用以脱离字典条目原式之集构建诸字典条目内容映射表 = 该字典构建诸字典条目内容映射表之方案_甲组.includes(该字典构建诸字典条目内容映射表之方案)
    const 外界须提供函数用以凭字典条目原式之集构建诸字典条目内容映射表 = 该字典构建诸字典条目内容映射表之方案_乙组.includes(该字典构建诸字典条目内容映射表之方案)



    // ══════════ 开始处理外界给出的【诸事之应对】 ════════════

    const {
        构建或获取该字典所有条目之原式,
    } = 诸事之应对

    if (typeof 构建或获取该字典所有条目之原式 !== 'function') {
        console.error(`${$_该字典机_消息前缀} 在用以构建该【字典机】的【形制要求总集】中：【\`构建或获取该字典所有条目之原式\`】不是函数。`)
        return null
    }



    let {
        凭字典条目原式之集构建诸字典条目内容映射表,
    } = 诸事之应对

    if (外界须提供函数用以凭字典条目原式之集构建诸字典条目内容映射表) {
        if (typeof 凭字典条目原式之集构建诸字典条目内容映射表 !== 'function') {
            if (typeof 所属字典群_内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法 === 'function') {
                凭字典条目原式之集构建诸字典条目内容映射表 = 所属字典群_内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法
            } else {
                console.error(
                    `${$_该字典机_消息前缀} 在用以构建该【字典机】的【形制要求总集】中：【\`凭字典条目原式之集构建诸字典条目内容映射表\`】不是函数。\n   `,
                    '同时上述【字典群之总机】的【\`内任何所谓标准字典_凭字典条目原式之集构建诸字典条目内容映射表_默认做法\`】也不是函数。'
                )

                return null
            }
        }
    } else {
        if (typeof 凭字典条目原式之集构建诸字典条目内容映射表 !== 'function') {
            凭字典条目原式之集构建诸字典条目内容映射表 = undefined
        }
    }



    let {
        凭某条目之原式构建其视式,
    } = 诸事之应对

    if (typeof 凭某条目之原式构建其视式 !== 'function') {
        if (typeof 所属字典群_内任何所谓标准字典_凭某条目之原式构建其视式_默认做法 === 'function') {
            凭某条目之原式构建其视式 = 所属字典群_内任何所谓标准字典_凭某条目之原式构建其视式_默认做法 as unknown as 范_该字典机_诸事之应对_完备式['凭某条目之原式构建其视式']
        } else {
            console.error(
                `${$_该字典机_消息前缀} 在用以构建该【字典机】的【形制要求总集】中：【\`凭某条目之原式构建其视式\`】不是函数。\n   `,
                '同时上述【字典群之总机】的【\`内任何所谓标准字典_凭某条目之原式构建其视式_默认做法\`】也不是函数。'
            )

            return null
        }
    }



    let {
        脱离字典条目原式之集构建诸字典条目内容映射表,
    } = 诸事之应对

    if (外界须提供函数用以脱离字典条目原式之集构建诸字典条目内容映射表) {
        if (typeof 脱离字典条目原式之集构建诸字典条目内容映射表 !== 'function') {
            console.error(`${$_该字典机_消息前缀} 在用以构建该【字典机】的【形制要求总集】中：【\`脱离字典条目原式之集构建诸字典条目内容映射表\`】不是函数。`)
            return null
        }
    } else {
        if (typeof 脱离字典条目原式之集构建诸字典条目内容映射表 !== 'function') {
            脱离字典条目原式之集构建诸字典条目内容映射表 = undefined
        }
    }



    let {
        该字典每次数据重建后,
    } = 诸事之应对

    if (typeof 该字典每次数据重建后 !== 'function') {
        该字典每次数据重建后 = undefined
    }



    // ══════════ 开始处理外界给出的【所持】 ════════════

    const 所持 = 求合规的非列表对象_若不合规则给出空的对象<范_该字典_范之零件_所持_形参准用式>(
        已知合规的形制要求总集['所持']
    )



    let 字典特别条目_其代表全选者_形参准用式 = 求合规的非列表对象_若不合规则给出null<范_该字典_字典特别条目_其代表全选者_形参准用式>(
        所持['字典特别条目_其代表全选者']
    )

    if (字典特别条目_其代表全选者_形参准用式) {
        const {
            当正常候选项个数为零时仍采用本特别项,
            应位于候选列表之该处,
            字典条目之视式,
        } = 字典特别条目_其代表全选者_形参准用式

        if (!是合规的非列表对象(字典条目之视式)) {
            console.error(`${$_该字典机_消息前缀} 在用以构建该【字典机】的【形制要求总集】中：【\`字典特别条目_其代表全选者\`】未附带合规的【\'字典条目之视式\'】。`)
            字典特别条目_其代表全选者_形参准用式 = null
        } else {
            if (typeof 应位于候选列表之该处 !== 'string' || ![
                '首部',
                '尾部',
            ].includes(应位于候选列表之该处)) {
                字典特别条目_其代表全选者_形参准用式.应位于候选列表之该处 = '首部'
            }

            const { 呈示称谓 } = 字典条目之视式
            if (typeof 呈示称谓 !== 'string') {
                字典条目之视式.呈示称谓 = 字典特别条目_其代表全选者_默认的呈示称谓
            }

            字典特别条目_其代表全选者_形参准用式.当正常候选项个数为零时仍采用本特别项 = !!当正常候选项个数为零时仍采用本特别项
        }
    }

    const 字典特别条目_其代表全选者: (null | 范_该字典_字典特别条目_其代表全选者_完备式) = 字典特别条目_其代表全选者_形参准用式 as (
        null | 范_该字典_字典特别条目_其代表全选者_完备式
    )



    let 字典特别条目_其代表全都不选者_形参准用式 = 求合规的非列表对象_若不合规则给出null<范_该字典_字典特别条目_其代表全都不选者_形参准用式>(
        所持['字典特别条目_其代表全都不选者']
    )

    if (字典特别条目_其代表全都不选者_形参准用式) {
        const { 应位于候选列表之该处, 字典条目之视式 } = 字典特别条目_其代表全都不选者_形参准用式

        if (!是合规的非列表对象(字典条目之视式)) {
            console.error(`${$_该字典机_消息前缀} 在用以构建该【字典机】的【形制要求总集】中：【\`字典特别条目_其代表全都不选者\`】未附带合规的【\'字典条目之视式\'】。`)
            字典特别条目_其代表全都不选者_形参准用式 = null
        } else {
            if (typeof 应位于候选列表之该处 !== 'string' || ![
                '首部',
                '尾部',
            ].includes(应位于候选列表之该处)) {
                字典特别条目_其代表全都不选者_形参准用式.应位于候选列表之该处 = '首部'
            }

            const { 呈示称谓 } = 字典条目之视式
            if (typeof 呈示称谓 !== 'string') {
                字典条目之视式.呈示称谓 = 字典特别条目_其代表全都不选者_默认的呈示称谓
            }
        }
    }

    const 字典特别条目_其代表全都不选者: (null | 范_该字典_字典特别条目_其代表全都不选者_完备式) = 字典特别条目_其代表全都不选者_形参准用式 as (
        null | 范_该字典_字典特别条目_其代表全都不选者_完备式
    )





    const _该字典机_凭该字典诸条目之原式_构建该字典诸条目之视式 = (): void => {
        if ($_该字典机已销毁) { return }



        const { 应构建字典条目之视式之哈希表 } = 该字典机.形制要求杂集

        const { 凭某条目之原式构建其视式 } = 该字典机.应对

        const {
            该字典诸条目之原式_其列表,
            字典特别条目_其代表全选者,
            字典特别条目_其代表全都不选者,
        } = 该字典机.所持

        if (!Array.isArray(该字典诸条目之原式_其列表)) { return }

        const 应采用代表全选之特别条目 = !!字典特别条目_其代表全选者 && (
            该字典诸条目之原式_其列表.length > 0 ||
            字典特别条目_其代表全选者.当正常候选项个数为零时仍采用本特别项
        )

        const 应采用代表全都不选之特别条目 = !!字典特别条目_其代表全都不选者

        type 范_该字典_条目视式集 = 范_该字典机['所持']['该字典诸条目之视式']

        const 字典条目之视式之列表: 范_该字典_条目视式集['其列表'] = []
        const 字典条目之视式之哈希表: 范_该字典_条目视式集['其哈希表'] = {}



        if (应采用代表全选之特别条目) {
            const {
                应位于候选列表之该处,
                字典条目之视式,
            } = 字典特别条目_其代表全选者

            if (应位于候选列表之该处 === '首部') {
                字典条目之视式之列表.push(字典条目之视式)
            }
        }

        if (字典特别条目_其代表全都不选者) {
            const {
                应位于候选列表之该处,
                字典条目之视式,
            } = 字典特别条目_其代表全都不选者

            if (应位于候选列表之该处 === '首部') {
                字典条目之视式之列表.push(字典条目之视式)
            }
        }



        该字典诸条目之原式_其列表.forEach(某字典条目之原式 => {
            const 字典条目之视式 = 凭某条目之原式构建其视式.call(this, 某字典条目之原式)
            if (!字典条目之视式) { return }
            const { 唯一标识 } = 字典条目之视式
            if (!是字典之合规的唯一标识(唯一标识)) { return }

            字典条目之视式之列表.push(字典条目之视式)

            if (应构建字典条目之视式之哈希表) {
                字典条目之视式之哈希表[唯一标识] = 字典条目之视式
            }
        })

        该字典机.所持.该字典诸条目之视式.其列表 = 字典条目之视式之列表
        该字典机.所持.该字典诸条目之视式.其哈希表 = 字典条目之视式之哈希表



        if (字典特别条目_其代表全都不选者) {
            const {
                应位于候选列表之该处,
                字典条目之视式,
            } = 字典特别条目_其代表全都不选者

            if (应位于候选列表之该处 === '尾部') {
                字典条目之视式之列表.push(字典条目之视式)
            }
        }

        if (应采用代表全选之特别条目) {
            const {
                应位于候选列表之该处,
                字典条目之视式,
            } = 字典特别条目_其代表全选者

            if (应位于候选列表之该处 === '尾部') {
                字典条目之视式之列表.push(字典条目之视式)
            }
        }
    }



    const _该字典机_按需构建诸字典条目内容映射表 = (): Promise<void> => {
        if ($_该字典机已销毁) { return Promise.reject() }



        const { 形制要求杂集, 态, 所持, 应对 } = 该字典机

        const {
            该字典构建诸字典条目内容映射表之方案,
        } = 形制要求杂集

        const {
            该字典诸字典条目内容映射表业已构建完毕,
        } = 态



        let 构建诸字典条目内容映射表一事已落实: Promise<void> = Promise.resolve()
        let 构建诸字典条目内容映射表之主体一事已落实: Promise<void> = Promise.resolve()



        if (该字典构建诸字典条目内容映射表之方案 === '不必构建') {
            return 构建诸字典条目内容映射表一事已落实
        }



        if (该字典构建诸字典条目内容映射表之方案 === '从该字典之诸条目原式之集提取而得') {
            const {
                该字典诸条目之原式_其列表,
            } = 所持

            const {
                凭字典条目原式之集构建诸字典条目内容映射表,
            } = 应对

            if (!该字典诸条目之原式_其列表) {
                console.error(`${$_该字典机_消息前缀} 其诸【字典条目内容映射表】的构建方案配置为 “${该字典构建诸字典条目内容映射表之方案}”。\n    但构建诸【字典条目内容映射表】时，发现【\`该字典诸条目之原式_其列表\`】尚不可用。`)
                return 构建诸字典条目内容映射表一事已落实
                // return Promise.reject()
            }

            if (typeof 凭字典条目原式之集构建诸字典条目内容映射表 !== 'function') {
                console.error(`${$_该字典机_消息前缀} 其诸【字典条目内容映射表】的构建方案配置为 “${该字典构建诸字典条目内容映射表之方案}”。\n    但构建诸【字典条目内容映射表】时，发现【\`凭字典条目原式之集构建诸字典条目内容映射表\`】不是函数。`)
                return 构建诸字典条目内容映射表一事已落实
                // return Promise.reject()
            }

            构建诸字典条目内容映射表之主体一事已落实 = 凭字典条目原式之集构建诸字典条目内容映射表.call(
                this,
                该字典诸条目之原式_其列表
            ).then(字典条目诸内容映射表之集 => {
                所持.字典条目诸内容映射表之集 = 字典条目诸内容映射表之集
                态.该字典诸字典条目内容映射表业已构建完毕 = true
            })
        }



        if (
            ([
                '脱离该字典之诸条目原式之集而构建，仅一次即可',
                '脱离该字典之诸条目原式之集而构建，且须反复获取或构建',
            ] as 范_单个字典构建诸字典条目内容映射表之方案[]
            ).includes(该字典构建诸字典条目内容映射表之方案)
        ) {
            if (该字典构建诸字典条目内容映射表之方案 === '脱离该字典之诸条目原式之集而构建，仅一次即可' && 该字典诸字典条目内容映射表业已构建完毕) {
                return 构建诸字典条目内容映射表一事已落实
            } else {
                if (该字典构建诸字典条目内容映射表之方案 === '脱离该字典之诸条目原式之集而构建，且须反复获取或构建') {
                    态.该字典诸字典条目内容映射表业已构建完毕 = false
                }
            }

            const {
                脱离字典条目原式之集构建诸字典条目内容映射表,
            } = 应对

            if (typeof 脱离字典条目原式之集构建诸字典条目内容映射表 !== 'function') {
                console.error(`${$_该字典机_消息前缀} 其诸【字典条目内容映射表】的构建方案配置为 “${该字典构建诸字典条目内容映射表之方案}”。\n    但构建诸【字典条目内容映射表】时，发现【\`脱离字典条目原式之集构建诸字典条目内容映射表\`】不是函数。`)
                return 构建诸字典条目内容映射表一事已落实
                // return Promise.reject()
            }

            构建诸字典条目内容映射表之主体一事已落实 = 脱离字典条目原式之集构建诸字典条目内容映射表.call(this).then(字典条目诸内容映射表之集 => {
                所持.字典条目诸内容映射表之集 = 字典条目诸内容映射表之集
                态.该字典诸字典条目内容映射表业已构建完毕 = true
            })
        }



        构建诸字典条目内容映射表一事已落实 = 构建诸字典条目内容映射表之主体一事已落实.then(function 在映射表中按需补充特别条目 () {
            const {
                字典条目诸内容映射表之集: {
                    从值至呈示称谓,
                    从呈示称谓至值,
                },
                字典特别条目_其代表全选者,
                字典特别条目_其代表全都不选者,
            } = 所持



            if (字典特别条目_其代表全选者) {
                const {
                    值,
                    呈示称谓,
                } = 字典特别条目_其代表全选者.字典条目之视式

                if (值 in 从值至呈示称谓) {
                    console.warn(`${$_该字典机_消息前缀} 其【字典条目内容映射表】中已有称谓为 “${从值至呈示称谓[值]}” 的条目取值为 “${值}”，故不会将称谓 “${呈示称谓}” 映射到该值。`)
                } else {
                    从值至呈示称谓[值] = 呈示称谓
                }

                if (呈示称谓 in 从呈示称谓至值) {
                    console.warn(`${$_该字典机_消息前缀} 其【字典条目内容映射表】中已有值为 “${值}” 的条目，其称谓为 “${从值至呈示称谓[值]}”，故不再将该值映射到称谓 “${呈示称谓}” 。`)
                } else {
                    从值至呈示称谓[呈示称谓] = 值
                }
            }



            if (字典特别条目_其代表全都不选者) {
                const {
                    值,
                    呈示称谓,
                } = 字典特别条目_其代表全都不选者.字典条目之视式

                if (值 in 从值至呈示称谓) {
                    console.warn(`${$_该字典机_消息前缀} 其【字典条目内容映射表】中已有称谓为 “${从值至呈示称谓[值]}” 的条目取值为 “${值}”，故不会将称谓 “${呈示称谓}” 映射到该值。`)
                } else {
                    从值至呈示称谓[值] = 呈示称谓
                }

                if (呈示称谓 in 从呈示称谓至值) {
                    console.warn(`${$_该字典机_消息前缀} 其【字典条目内容映射表】中已有值为 “${值}” 的条目，其称谓为 “${从值至呈示称谓[值]}”，故不再将该值映射到称谓 “${呈示称谓}” 。`)
                } else {
                    从值至呈示称谓[呈示称谓] = 值
                }
            }
        })



        return 构建诸字典条目内容映射表一事已落实
    }



    const _该字典机_清空数据 = (): void => {
        const { 态, 所持 } = 该字典机

        所持.该字典诸条目之原式_其列表 = null
        所持.该字典诸条目之视式.其列表 = []
        所持.该字典诸条目之视式.其哈希表 = {}
        所持.字典条目诸内容映射表之集.从值至呈示称谓 = {}
        所持.字典条目诸内容映射表之集.从呈示称谓至值 = {}

        态.当下的数据系某次成功构建而得的 = false
    }



    const _该字典机_自毁 = (): void => {
        const { 态 } = 该字典机

        _该字典机_清空数据()

        if (typeof $_该字典机_期待_最末一次数据重构_落空之 === 'function') {
            $_该字典机_期待_最末一次数据重构_落空之(`${$_该字典机_消息前缀} 因自毁而中止数据重构任务。`)
        }

        $_该字典机已销毁 = true
        态._已销毁 = true
        该字典机的调试信息之详尽等级 >= 1 && console.debug(`${$_该字典机_消息前缀} 已自毁。`)
    }



    const _该字典机_重建数据 = (...参数表_用以获取字典诸条目之原式: any[]): Promise<void> => {
        if ($_该字典机已销毁) {
            // return Promise.resolve()
            return Promise.reject()
        }



        const { 形制要求杂集, 态, 应对 } = 该字典机

        if (态.当下正在构建数据) {
            该字典机的调试信息之详尽等级 >= 2 && console.debug(`${$_该字典机_消息前缀} 已经在重建数据，且该【数据重建】之任务尚未完毕。\n    须知，任何【字典机】都不会并行多个【数据重建】任务。`)
            return 态.期待_最末一次构建数据之任务已完毕
        }



        _该字典机_清空数据()

        态.当下正在构建数据 = true
        该字典机的调试信息之详尽等级 >= 1 && console.debug(`${$_该字典机_消息前缀} 开始重建数据。`)

        const 期待_本次重建数据完毕: Promise<void> = new Promise((落实, 落空) => {
            $_该字典机_期待_最末一次数据重构_落实之 = 落实
            $_该字典机_期待_最末一次数据重构_落空之 = 落空
        }).then(() => {
            态.当下正在构建数据 = false
            $_该字典机_期待_最末一次数据重构_落实之 = undefined
            $_该字典机_期待_最末一次数据重构_落空之 = undefined

            该字典机的调试信息之详尽等级 >= 1 && console.debug(`${$_该字典机_消息前缀} 本轮【数据重建】任务完毕。`)

            $_该字典机_发布消息_数据已重建一次()
        }).catch(异常之记载 => {
            态.当下正在构建数据 = false
            $_该字典机_期待_最末一次数据重构_落实之 = undefined
            $_该字典机_期待_最末一次数据重构_落空之 = undefined

            console.warn(`${$_该字典机_消息前缀} 本轮【数据重建】任务异常。`)

            return Promise.reject(异常之记载)
        })

        态.期待_最末一次构建数据之任务已完毕 = 期待_本次重建数据完毕



        const {
            该字典构建诸字典条目内容映射表之方案,
        } = 形制要求杂集

        let 独立构建诸字典条目内容映射表一事已落实: Promise<void>
        if (
            ([
                '脱离该字典之诸条目原式之集而构建，仅一次即可',
                '脱离该字典之诸条目原式之集而构建，且须反复获取或构建',
            ] as 范_单个字典构建诸字典条目内容映射表之方案[]
            ).includes(该字典构建诸字典条目内容映射表之方案)
        ) {
            独立构建诸字典条目内容映射表一事已落实 = _该字典机_按需构建诸字典条目内容映射表()
        } else {
            独立构建诸字典条目内容映射表一事已落实 = Promise.resolve()
        }



        Promise.all([
            独立构建诸字典条目内容映射表一事已落实,

            应对.构建或获取该字典所有条目之原式.call(
                this,
                所属字典群之总机,
                该字典机,
                参数表_用以获取字典诸条目之原式
            ).then(该字典诸条目之原式_其列表 => {
                该字典机.所持.该字典诸条目之原式_其列表 = 该字典诸条目之原式_其列表
            }),
        ]).then(() => {
            _该字典机_凭该字典诸条目之原式_构建该字典诸条目之视式()

            态.当下的数据系某次成功构建而得的 = true

            if (
                ([
                    '从该字典之诸条目原式之集提取而得',
                ] as 范_单个字典构建诸字典条目内容映射表之方案[]
                ).includes(该字典构建诸字典条目内容映射表之方案)
            ) {
                return _该字典机_按需构建诸字典条目内容映射表()
            }
        }).then(() => {
            if (typeof $_该字典机_期待_最末一次数据重构_落实之 === 'function') {
                $_该字典机_期待_最末一次数据重构_落实之()
            }
        }).catch(异常之记载 => {
            if (typeof $_该字典机_期待_最末一次数据重构_落空之 === 'function') {
                $_该字典机_期待_最末一次数据重构_落空之(异常之记载)
            }
        })



        return 期待_本次重建数据完毕
    }



    const _该字典机_凭某条目之值求其呈示称谓 = (所涉条目之值?: any): string | undefined => {
        if ($_该字典机已销毁) { return }

        if ([ null, undefined ].includes(所涉条目之值)) {
            return
        }

        const { 从值至呈示称谓 } = 该字典机.所持.字典条目诸内容映射表之集
        let 查得的措辞: string | undefined
        查得的措辞 = 从值至呈示称谓[`${所涉条目之值}`]

        if (typeof 查得的措辞 === 'string') {
            return 查得的措辞
        }

        return `${所涉条目之值}`
    }



    const $_该字典机_发布消息_数据已重建一次 = (): void => {
        if ($_该字典机已销毁) { return }

        const {
            该字典每次数据重建后,
        } = 该字典机.应对

        if (typeof 该字典每次数据重建后 === 'function') {
            该字典每次数据重建后.call(this, 所属字典群之总机, 该字典机)
        }

        if (typeof 所属字典群_内任何字典_某次数据重建后_统一做法 === 'function') {
            所属字典群_内任何字典_某次数据重建后_统一做法.call(
                this,
                所属字典群之总机,
                该字典机 as 范_字典机<范_该字典机_其This, any, any>
            )
        }
    }



    const 该字典机: 范_该字典机 = {
        该字典之唯一标识,

        所持: {
            字典特别条目_其代表全选者,
            字典特别条目_其代表全都不选者,

            该字典诸条目之原式_其列表: null,

            该字典诸条目之视式: {
                其列表: [],
                其哈希表: {},
            },

            字典条目诸内容映射表之集: {
                从值至呈示称谓: {},
                从呈示称谓至值: {},
            },
        },

        态: {
            _已销毁: false,

            该字典诸字典条目内容映射表业已构建完毕: false,
            当下的数据系某次成功构建而得的: false,
            当下正在构建数据: false,
            期待_最末一次构建数据之任务已完毕: Promise.resolve(),
        },

        为: {
            清空数据: _该字典机_清空数据,
            重建数据: _该字典机_重建数据,
            凭某条目之值求其呈示称谓: _该字典机_凭某条目之值求其呈示称谓,
            自毁: _该字典机_自毁,
        },

        形制要求杂集: {
            该字典机的调试信息之详尽等级,
            该字典构建诸字典条目内容映射表之方案,
            该字典在默认情形下不参与字典群总机发起的数据重建任务,
            应构建字典条目之视式之哈希表,
        },

        应对: {
            构建或获取该字典所有条目之原式,
            脱离字典条目原式之集构建诸字典条目内容映射表,
            凭字典条目原式之集构建诸字典条目内容映射表,
            凭某条目之原式构建其视式,
            该字典每次数据重建后,
        },
    }

    return 该字典机
}
